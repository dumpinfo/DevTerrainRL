<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - code analysis - /usr/include/glog/logging.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">usr/include/glog</a> - logging.h<span style="font-size: 80%;"> (source / <a href="logging.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">code analysis</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-06-13 04:47:02</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 1999, Google Inc.</a>
<span class="lineNum">       2 </span>            : // All rights reserved.
<span class="lineNum">       3 </span>            : //
<span class="lineNum">       4 </span>            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       5 </span>            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       6 </span>            : // met:
<span class="lineNum">       7 </span>            : //
<span class="lineNum">       8 </span>            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">       9 </span>            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      10 </span>            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      11 </span>            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      12 </span>            : // in the documentation and/or other materials provided with the
<span class="lineNum">      13 </span>            : // distribution.
<span class="lineNum">      14 </span>            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      15 </span>            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      16 </span>            : // this software without specific prior written permission.
<span class="lineNum">      17 </span>            : //
<span class="lineNum">      18 </span>            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      19 </span>            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      20 </span>            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      21 </span>            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      22 </span>            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      23 </span>            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      24 </span>            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      25 </span>            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      26 </span>            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      27 </span>            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      28 </span>            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      29 </span>            : //
<span class="lineNum">      30 </span>            : // Author: Ray Sidney
<span class="lineNum">      31 </span>            : //
<span class="lineNum">      32 </span>            : // This file contains #include information about logging-related stuff.
<span class="lineNum">      33 </span>            : // Pretty much everybody needs to #include this file so that they can
<span class="lineNum">      34 </span>            : // log various happenings.
<span class="lineNum">      35 </span>            : //
<span class="lineNum">      36 </span>            : #ifndef _LOGGING_H_
<span class="lineNum">      37 </span>            : #define _LOGGING_H_
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;iosfwd&gt;
<span class="lineNum">      43 </span>            : #include &lt;ostream&gt;
<span class="lineNum">      44 </span>            : #include &lt;sstream&gt;
<span class="lineNum">      45 </span>            : #include &lt;string&gt;
<span class="lineNum">      46 </span>            : #if 1
<span class="lineNum">      47 </span>            : # include &lt;unistd.h&gt;
<span class="lineNum">      48 </span>            : #endif
<span class="lineNum">      49 </span>            : #include &lt;vector&gt;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // Annoying stuff for windows -- makes sure clients can import these functions
<span class="lineNum">      52 </span>            : #ifndef GOOGLE_GLOG_DLL_DECL
<span class="lineNum">      53 </span>            : # if defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)
<span class="lineNum">      54 </span>            : #   define GOOGLE_GLOG_DLL_DECL  __declspec(dllimport)
<span class="lineNum">      55 </span>            : # else
<span class="lineNum">      56 </span>            : #   define GOOGLE_GLOG_DLL_DECL
<span class="lineNum">      57 </span>            : # endif
<span class="lineNum">      58 </span>            : #endif
<span class="lineNum">      59 </span>            : #if defined(_MSC_VER)
<span class="lineNum">      60 </span>            : #define GLOG_MSVC_PUSH_DISABLE_WARNING(n) __pragma(warning(push)) \
<span class="lineNum">      61 </span>            :                                      __pragma(warning(disable:n))
<span class="lineNum">      62 </span>            : #define GLOG_MSVC_POP_WARNING() __pragma(warning(pop))
<span class="lineNum">      63 </span>            : #else
<span class="lineNum">      64 </span>            : #define GLOG_MSVC_PUSH_DISABLE_WARNING(n)
<span class="lineNum">      65 </span>            : #define GLOG_MSVC_POP_WARNING()
<span class="lineNum">      66 </span>            : #endif
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : // We care a lot about number of bits things take up.  Unfortunately,
<span class="lineNum">      69 </span>            : // systems define their bit-specific ints in a lot of different ways.
<span class="lineNum">      70 </span>            : // We use our own way, and have a typedef to get there.
<span class="lineNum">      71 </span>            : // Note: these commands below may look like &quot;#if 1&quot; or &quot;#if 0&quot;, but
<span class="lineNum">      72 </span>            : // that's because they were constructed that way at ./configure time.
<span class="lineNum">      73 </span>            : // Look at logging.h.in to see how they're calculated (based on your config).
<span class="lineNum">      74 </span>            : #if 1
<span class="lineNum">      75 </span>            : #include &lt;stdint.h&gt;             // the normal place uint16_t is defined
<span class="lineNum">      76 </span>            : #endif
<span class="lineNum">      77 </span>            : #if 1
<span class="lineNum">      78 </span>            : #include &lt;sys/types.h&gt;          // the normal place u_int16_t is defined
<span class="lineNum">      79 </span>            : #endif
<span class="lineNum">      80 </span>            : #if 1
<span class="lineNum">      81 </span>            : #include &lt;inttypes.h&gt;           // a third place for uint16_t or u_int16_t
<span class="lineNum">      82 </span>            : #endif
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : #if 1
<span class="lineNum">      85 </span>            : #include &lt;gflags/gflags.h&gt;
<span class="lineNum">      86 </span>            : #endif
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : namespace google {
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #if 1      // the C99 format
<span class="lineNum">      91 </span>            : typedef int32_t int32;
<span class="lineNum">      92 </span>            : typedef uint32_t uint32;
<span class="lineNum">      93 </span>            : typedef int64_t int64;
<span class="lineNum">      94 </span>            : typedef uint64_t uint64;
<span class="lineNum">      95 </span>            : #elif 1   // the BSD format
<span class="lineNum">      96 </span>            : typedef int32_t int32;
<span class="lineNum">      97 </span>            : typedef u_int32_t uint32;
<span class="lineNum">      98 </span>            : typedef int64_t int64;
<span class="lineNum">      99 </span>            : typedef u_int64_t uint64;
<span class="lineNum">     100 </span>            : #elif 0    // the windows (vc7) format
<span class="lineNum">     101 </span>            : typedef __int32 int32;
<span class="lineNum">     102 </span>            : typedef unsigned __int32 uint32;
<span class="lineNum">     103 </span>            : typedef __int64 int64;
<span class="lineNum">     104 </span>            : typedef unsigned __int64 uint64;
<span class="lineNum">     105 </span>            : #else
<span class="lineNum">     106 </span>            : #error Do not know how to define a 32-bit integer quantity on your system
<span class="lineNum">     107 </span>            : #endif
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : }
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : // The global value of GOOGLE_STRIP_LOG. All the messages logged to
<span class="lineNum">     112 </span>            : // LOG(XXX) with severity less than GOOGLE_STRIP_LOG will not be displayed.
<span class="lineNum">     113 </span>            : // If it can be determined at compile time that the message will not be
<span class="lineNum">     114 </span>            : // printed, the statement will be compiled out.
<span class="lineNum">     115 </span>            : //
<span class="lineNum">     116 </span>            : // Example: to strip out all INFO and WARNING messages, use the value
<span class="lineNum">     117 </span>            : // of 2 below. To make an exception for WARNING messages from a single
<span class="lineNum">     118 </span>            : // file, add &quot;#define GOOGLE_STRIP_LOG 1&quot; to that file _before_ including
<span class="lineNum">     119 </span>            : // base/logging.h
<span class="lineNum">     120 </span>            : #ifndef GOOGLE_STRIP_LOG
<span class="lineNum">     121 </span>            : #define GOOGLE_STRIP_LOG 0
<span class="lineNum">     122 </span>            : #endif
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : // GCC can be told that a certain branch is not likely to be taken (for
<span class="lineNum">     125 </span>            : // instance, a CHECK failure), and use that information in static analysis.
<span class="lineNum">     126 </span>            : // Giving it this information can help it optimize for the common case in
<span class="lineNum">     127 </span>            : // the absence of better information (ie. -fprofile-arcs).
<span class="lineNum">     128 </span>            : //
<span class="lineNum">     129 </span>            : #ifndef GOOGLE_PREDICT_BRANCH_NOT_TAKEN
<span class="lineNum">     130 </span>            : #if 1
<span class="lineNum">     131 </span>            : #define GOOGLE_PREDICT_BRANCH_NOT_TAKEN(x) (__builtin_expect(x, 0))
<span class="lineNum">     132 </span>            : #define GOOGLE_PREDICT_FALSE(x) (__builtin_expect(x, 0))
<span class="lineNum">     133 </span>            : #define GOOGLE_PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))
<span class="lineNum">     134 </span>            : #else
<span class="lineNum">     135 </span>            : #define GOOGLE_PREDICT_BRANCH_NOT_TAKEN(x) x
<span class="lineNum">     136 </span>            : #define GOOGLE_PREDICT_FALSE(x) x
<span class="lineNum">     137 </span>            : #define GOOGLE_PREDICT_TRUE(x) x
<span class="lineNum">     138 </span>            : #endif
<span class="lineNum">     139 </span>            : #endif
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : // Make a bunch of macros for logging.  The way to log things is to stream
<span class="lineNum">     142 </span>            : // things to LOG(&lt;a particular severity level&gt;).  E.g.,
<span class="lineNum">     143 </span>            : //
<span class="lineNum">     144 </span>            : //   LOG(INFO) &lt;&lt; &quot;Found &quot; &lt;&lt; num_cookies &lt;&lt; &quot; cookies&quot;;
<span class="lineNum">     145 </span>            : //
<span class="lineNum">     146 </span>            : // You can capture log messages in a string, rather than reporting them
<span class="lineNum">     147 </span>            : // immediately:
<span class="lineNum">     148 </span>            : //
<span class="lineNum">     149 </span>            : //   vector&lt;string&gt; errors;
<span class="lineNum">     150 </span>            : //   LOG_STRING(ERROR, &amp;errors) &lt;&lt; &quot;Couldn't parse cookie #&quot; &lt;&lt; cookie_num;
<span class="lineNum">     151 </span>            : //
<span class="lineNum">     152 </span>            : // This pushes back the new error onto 'errors'; if given a NULL pointer,
<span class="lineNum">     153 </span>            : // it reports the error via LOG(ERROR).
<span class="lineNum">     154 </span>            : //
<span class="lineNum">     155 </span>            : // You can also do conditional logging:
<span class="lineNum">     156 </span>            : //
<span class="lineNum">     157 </span>            : //   LOG_IF(INFO, num_cookies &gt; 10) &lt;&lt; &quot;Got lots of cookies&quot;;
<span class="lineNum">     158 </span>            : //
<span class="lineNum">     159 </span>            : // You can also do occasional logging (log every n'th occurrence of an
<span class="lineNum">     160 </span>            : // event):
<span class="lineNum">     161 </span>            : //
<span class="lineNum">     162 </span>            : //   LOG_EVERY_N(INFO, 10) &lt;&lt; &quot;Got the &quot; &lt;&lt; google::COUNTER &lt;&lt; &quot;th cookie&quot;;
<span class="lineNum">     163 </span>            : //
<span class="lineNum">     164 </span>            : // The above will cause log messages to be output on the 1st, 11th, 21st, ...
<span class="lineNum">     165 </span>            : // times it is executed.  Note that the special google::COUNTER value is used
<span class="lineNum">     166 </span>            : // to identify which repetition is happening.
<span class="lineNum">     167 </span>            : //
<span class="lineNum">     168 </span>            : // You can also do occasional conditional logging (log every n'th
<span class="lineNum">     169 </span>            : // occurrence of an event, when condition is satisfied):
<span class="lineNum">     170 </span>            : //
<span class="lineNum">     171 </span>            : //   LOG_IF_EVERY_N(INFO, (size &gt; 1024), 10) &lt;&lt; &quot;Got the &quot; &lt;&lt; google::COUNTER
<span class="lineNum">     172 </span>            : //                                           &lt;&lt; &quot;th big cookie&quot;;
<span class="lineNum">     173 </span>            : //
<span class="lineNum">     174 </span>            : // You can log messages the first N times your code executes a line. E.g.
<span class="lineNum">     175 </span>            : //
<span class="lineNum">     176 </span>            : //   LOG_FIRST_N(INFO, 20) &lt;&lt; &quot;Got the &quot; &lt;&lt; google::COUNTER &lt;&lt; &quot;th cookie&quot;;
<span class="lineNum">     177 </span>            : //
<span class="lineNum">     178 </span>            : // Outputs log messages for the first 20 times it is executed.
<span class="lineNum">     179 </span>            : //
<span class="lineNum">     180 </span>            : // Analogous SYSLOG, SYSLOG_IF, and SYSLOG_EVERY_N macros are available.
<span class="lineNum">     181 </span>            : // These log to syslog as well as to the normal logs.  If you use these at
<span class="lineNum">     182 </span>            : // all, you need to be aware that syslog can drastically reduce performance,
<span class="lineNum">     183 </span>            : // especially if it is configured for remote logging!  Don't use these
<span class="lineNum">     184 </span>            : // unless you fully understand this and have a concrete need to use them.
<span class="lineNum">     185 </span>            : // Even then, try to minimize your use of them.
<span class="lineNum">     186 </span>            : //
<span class="lineNum">     187 </span>            : // There are also &quot;debug mode&quot; logging macros like the ones above:
<span class="lineNum">     188 </span>            : //
<span class="lineNum">     189 </span>            : //   DLOG(INFO) &lt;&lt; &quot;Found cookies&quot;;
<span class="lineNum">     190 </span>            : //
<span class="lineNum">     191 </span>            : //   DLOG_IF(INFO, num_cookies &gt; 10) &lt;&lt; &quot;Got lots of cookies&quot;;
<span class="lineNum">     192 </span>            : //
<span class="lineNum">     193 </span>            : //   DLOG_EVERY_N(INFO, 10) &lt;&lt; &quot;Got the &quot; &lt;&lt; google::COUNTER &lt;&lt; &quot;th cookie&quot;;
<span class="lineNum">     194 </span>            : //
<span class="lineNum">     195 </span>            : // All &quot;debug mode&quot; logging is compiled away to nothing for non-debug mode
<span class="lineNum">     196 </span>            : // compiles.
<span class="lineNum">     197 </span>            : //
<span class="lineNum">     198 </span>            : // We also have
<span class="lineNum">     199 </span>            : //
<span class="lineNum">     200 </span>            : //   LOG_ASSERT(assertion);
<span class="lineNum">     201 </span>            : //   DLOG_ASSERT(assertion);
<span class="lineNum">     202 </span>            : //
<span class="lineNum">     203 </span>            : // which is syntactic sugar for {,D}LOG_IF(FATAL, assert fails) &lt;&lt; assertion;
<span class="lineNum">     204 </span>            : //
<span class="lineNum">     205 </span>            : // There are &quot;verbose level&quot; logging macros.  They look like
<span class="lineNum">     206 </span>            : //
<span class="lineNum">     207 </span>            : //   VLOG(1) &lt;&lt; &quot;I'm printed when you run the program with --v=1 or more&quot;;
<span class="lineNum">     208 </span>            : //   VLOG(2) &lt;&lt; &quot;I'm printed when you run the program with --v=2 or more&quot;;
<span class="lineNum">     209 </span>            : //
<span class="lineNum">     210 </span>            : // These always log at the INFO log level (when they log at all).
<span class="lineNum">     211 </span>            : // The verbose logging can also be turned on module-by-module.  For instance,
<span class="lineNum">     212 </span>            : //    --vmodule=mapreduce=2,file=1,gfs*=3 --v=0
<span class="lineNum">     213 </span>            : // will cause:
<span class="lineNum">     214 </span>            : //   a. VLOG(2) and lower messages to be printed from mapreduce.{h,cc}
<span class="lineNum">     215 </span>            : //   b. VLOG(1) and lower messages to be printed from file.{h,cc}
<span class="lineNum">     216 </span>            : //   c. VLOG(3) and lower messages to be printed from files prefixed with &quot;gfs&quot;
<span class="lineNum">     217 </span>            : //   d. VLOG(0) and lower messages to be printed from elsewhere
<span class="lineNum">     218 </span>            : //
<span class="lineNum">     219 </span>            : // The wildcarding functionality shown by (c) supports both '*' (match
<span class="lineNum">     220 </span>            : // 0 or more characters) and '?' (match any single character) wildcards.
<span class="lineNum">     221 </span>            : //
<span class="lineNum">     222 </span>            : // There's also VLOG_IS_ON(n) &quot;verbose level&quot; condition macro. To be used as
<span class="lineNum">     223 </span>            : //
<span class="lineNum">     224 </span>            : //   if (VLOG_IS_ON(2)) {
<span class="lineNum">     225 </span>            : //     // do some logging preparation and logging
<span class="lineNum">     226 </span>            : //     // that can't be accomplished with just VLOG(2) &lt;&lt; ...;
<span class="lineNum">     227 </span>            : //   }
<span class="lineNum">     228 </span>            : //
<span class="lineNum">     229 </span>            : // There are also VLOG_IF, VLOG_EVERY_N and VLOG_IF_EVERY_N &quot;verbose level&quot;
<span class="lineNum">     230 </span>            : // condition macros for sample cases, when some extra computation and
<span class="lineNum">     231 </span>            : // preparation for logs is not needed.
<span class="lineNum">     232 </span>            : //   VLOG_IF(1, (size &gt; 1024))
<span class="lineNum">     233 </span>            : //      &lt;&lt; &quot;I'm printed when size is more than 1024 and when you run the &quot;
<span class="lineNum">     234 </span>            : //         &quot;program with --v=1 or more&quot;;
<span class="lineNum">     235 </span>            : //   VLOG_EVERY_N(1, 10)
<span class="lineNum">     236 </span>            : //      &lt;&lt; &quot;I'm printed every 10th occurrence, and when you run the program &quot;
<span class="lineNum">     237 </span>            : //         &quot;with --v=1 or more. Present occurence is &quot; &lt;&lt; google::COUNTER;
<span class="lineNum">     238 </span>            : //   VLOG_IF_EVERY_N(1, (size &gt; 1024), 10)
<span class="lineNum">     239 </span>            : //      &lt;&lt; &quot;I'm printed on every 10th occurence of case when size is more &quot;
<span class="lineNum">     240 </span>            : //         &quot; than 1024, when you run the program with --v=1 or more. &quot;;
<span class="lineNum">     241 </span>            : //         &quot;Present occurence is &quot; &lt;&lt; google::COUNTER;
<span class="lineNum">     242 </span>            : //
<span class="lineNum">     243 </span>            : // The supported severity levels for macros that allow you to specify one
<span class="lineNum">     244 </span>            : // are (in increasing order of severity) INFO, WARNING, ERROR, and FATAL.
<span class="lineNum">     245 </span>            : // Note that messages of a given severity are logged not only in the
<span class="lineNum">     246 </span>            : // logfile for that severity, but also in all logfiles of lower severity.
<span class="lineNum">     247 </span>            : // E.g., a message of severity FATAL will be logged to the logfiles of
<span class="lineNum">     248 </span>            : // severity FATAL, ERROR, WARNING, and INFO.
<span class="lineNum">     249 </span>            : //
<span class="lineNum">     250 </span>            : // There is also the special severity of DFATAL, which logs FATAL in
<span class="lineNum">     251 </span>            : // debug mode, ERROR in normal mode.
<span class="lineNum">     252 </span>            : //
<span class="lineNum">     253 </span>            : // Very important: logging a message at the FATAL severity level causes
<span class="lineNum">     254 </span>            : // the program to terminate (after the message is logged).
<span class="lineNum">     255 </span>            : //
<span class="lineNum">     256 </span>            : // Unless otherwise specified, logs will be written to the filename
<span class="lineNum">     257 </span>            : // &quot;&lt;program name&gt;.&lt;hostname&gt;.&lt;user name&gt;.log.&lt;severity level&gt;.&quot;, followed
<span class="lineNum">     258 </span>            : // by the date, time, and pid (you can't prevent the date, time, and pid
<span class="lineNum">     259 </span>            : // from being in the filename).
<span class="lineNum">     260 </span>            : //
<span class="lineNum">     261 </span>            : // The logging code takes two flags:
<span class="lineNum">     262 </span>            : //     --v=#           set the verbose level
<span class="lineNum">     263 </span>            : //     --logtostderr   log all the messages to stderr instead of to logfiles
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : // LOG LINE PREFIX FORMAT
<span class="lineNum">     266 </span>            : //
<span class="lineNum">     267 </span>            : // Log lines have this form:
<span class="lineNum">     268 </span>            : //
<span class="lineNum">     269 </span>            : //     Lmmdd hh:mm:ss.uuuuuu threadid file:line] msg...
<span class="lineNum">     270 </span>            : //
<span class="lineNum">     271 </span>            : // where the fields are defined as follows:
<span class="lineNum">     272 </span>            : //
<span class="lineNum">     273 </span>            : //   L                A single character, representing the log level
<span class="lineNum">     274 </span>            : //                    (eg 'I' for INFO)
<span class="lineNum">     275 </span>            : //   mm               The month (zero padded; ie May is '05')
<span class="lineNum">     276 </span>            : //   dd               The day (zero padded)
<span class="lineNum">     277 </span>            : //   hh:mm:ss.uuuuuu  Time in hours, minutes and fractional seconds
<span class="lineNum">     278 </span>            : //   threadid         The space-padded thread ID as returned by GetTID()
<span class="lineNum">     279 </span>            : //                    (this matches the PID on Linux)
<span class="lineNum">     280 </span>            : //   file             The file name
<span class="lineNum">     281 </span>            : //   line             The line number
<span class="lineNum">     282 </span>            : //   msg              The user-supplied message
<span class="lineNum">     283 </span>            : //
<span class="lineNum">     284 </span>            : // Example:
<span class="lineNum">     285 </span>            : //
<span class="lineNum">     286 </span>            : //   I1103 11:57:31.739339 24395 google.cc:2341] Command line: ./some_prog
<span class="lineNum">     287 </span>            : //   I1103 11:57:31.739403 24395 google.cc:2342] Process id 24395
<span class="lineNum">     288 </span>            : //
<span class="lineNum">     289 </span>            : // NOTE: although the microseconds are useful for comparing events on
<span class="lineNum">     290 </span>            : // a single machine, clocks on different machines may not be well
<span class="lineNum">     291 </span>            : // synchronized.  Hence, use caution when comparing the low bits of
<span class="lineNum">     292 </span>            : // timestamps from different machines.
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : #ifndef DECLARE_VARIABLE
<span class="lineNum">     295 </span>            : #define MUST_UNDEF_GFLAGS_DECLARE_MACROS
<span class="lineNum">     296 </span>            : #define DECLARE_VARIABLE(type, shorttype, name, tn)                     \
<span class="lineNum">     297 </span>            :   namespace fL##shorttype {                                             \
<span class="lineNum">     298 </span>            :     extern GOOGLE_GLOG_DLL_DECL type FLAGS_##name;                      \
<span class="lineNum">     299 </span>            :   }                                                                     \
<span class="lineNum">     300 </span>            :   using fL##shorttype::FLAGS_##name
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : // bool specialization
<span class="lineNum">     303 </span>            : #define DECLARE_bool(name) \
<span class="lineNum">     304 </span>            :   DECLARE_VARIABLE(bool, B, name, bool)
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : // int32 specialization
<span class="lineNum">     307 </span>            : #define DECLARE_int32(name) \
<span class="lineNum">     308 </span>            :   DECLARE_VARIABLE(google::int32, I, name, int32)
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : // Special case for string, because we have to specify the namespace
<span class="lineNum">     311 </span>            : // std::string, which doesn't play nicely with our FLAG__namespace hackery.
<span class="lineNum">     312 </span>            : #define DECLARE_string(name)                                            \
<span class="lineNum">     313 </span>            :   namespace fLS {                                                       \
<span class="lineNum">     314 </span>            :     extern GOOGLE_GLOG_DLL_DECL std::string&amp; FLAGS_##name;              \
<span class="lineNum">     315 </span>            :   }                                                                     \
<span class="lineNum">     316 </span>            :   using fLS::FLAGS_##name
<span class="lineNum">     317 </span>            : #endif
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : // Set whether log messages go to stderr instead of logfiles
<span class="lineNum">     320 </span>            : DECLARE_bool(logtostderr);
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : // Set whether log messages go to stderr in addition to logfiles.
<span class="lineNum">     323 </span>            : DECLARE_bool(alsologtostderr);
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : // Set color messages logged to stderr (if supported by terminal).
<span class="lineNum">     326 </span>            : DECLARE_bool(colorlogtostderr);
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : // Log messages at a level &gt;= this flag are automatically sent to
<span class="lineNum">     329 </span>            : // stderr in addition to log files.
<span class="lineNum">     330 </span>            : DECLARE_int32(stderrthreshold);
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : // Set whether the log prefix should be prepended to each line of output.
<span class="lineNum">     333 </span>            : DECLARE_bool(log_prefix);
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            : // Log messages at a level &lt;= this flag are buffered.
<span class="lineNum">     336 </span>            : // Log messages at a higher level are flushed immediately.
<span class="lineNum">     337 </span>            : DECLARE_int32(logbuflevel);
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : // Sets the maximum number of seconds which logs may be buffered for.
<span class="lineNum">     340 </span>            : DECLARE_int32(logbufsecs);
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : // Log suppression level: messages logged at a lower level than this
<span class="lineNum">     343 </span>            : // are suppressed.
<span class="lineNum">     344 </span>            : DECLARE_int32(minloglevel);
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : // If specified, logfiles are written into this directory instead of the
<span class="lineNum">     347 </span>            : // default logging directory.
<span class="lineNum">     348 </span>            : DECLARE_string(log_dir);
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : // Sets the path of the directory into which to put additional links
<span class="lineNum">     351 </span>            : // to the log files.
<span class="lineNum">     352 </span>            : DECLARE_string(log_link);
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : DECLARE_int32(v);  // in vlog_is_on.cc
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : // Sets the maximum log file size (in MB).
<span class="lineNum">     357 </span>            : DECLARE_int32(max_log_size);
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : // Sets whether to avoid logging to the disk if the disk is full.
<span class="lineNum">     360 </span>            : DECLARE_bool(stop_logging_if_full_disk);
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : #ifdef MUST_UNDEF_GFLAGS_DECLARE_MACROS
<span class="lineNum">     363 </span>            : #undef MUST_UNDEF_GFLAGS_DECLARE_MACROS
<span class="lineNum">     364 </span>            : #undef DECLARE_VARIABLE
<span class="lineNum">     365 </span>            : #undef DECLARE_bool
<span class="lineNum">     366 </span>            : #undef DECLARE_int32
<span class="lineNum">     367 </span>            : #undef DECLARE_string
<span class="lineNum">     368 </span>            : #endif
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : // Log messages below the GOOGLE_STRIP_LOG level will be compiled away for
<span class="lineNum">     371 </span>            : // security reasons. See LOG(severtiy) below.
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : // A few definitions of macros that don't generate much code.  Since
<span class="lineNum">     374 </span>            : // LOG(INFO) and its ilk are used all over our code, it's
<span class="lineNum">     375 </span>            : // better to have compact code for these operations.
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : #if GOOGLE_STRIP_LOG == 0
<span class="lineNum">     378 </span>            : #define COMPACT_GOOGLE_LOG_INFO google::LogMessage( \
<span class="lineNum">     379 </span>            :       __FILE__, __LINE__)
<span class="lineNum">     380 </span>            : #define LOG_TO_STRING_INFO(message) google::LogMessage( \
<span class="lineNum">     381 </span>            :       __FILE__, __LINE__, google::GLOG_INFO, message)
<span class="lineNum">     382 </span>            : #else
<span class="lineNum">     383 </span>            : #define COMPACT_GOOGLE_LOG_INFO google::NullStream()
<span class="lineNum">     384 </span>            : #define LOG_TO_STRING_INFO(message) google::NullStream()
<span class="lineNum">     385 </span>            : #endif
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : #if GOOGLE_STRIP_LOG &lt;= 1
<span class="lineNum">     388 </span>            : #define COMPACT_GOOGLE_LOG_WARNING google::LogMessage( \
<span class="lineNum">     389 </span>            :       __FILE__, __LINE__, google::GLOG_WARNING)
<span class="lineNum">     390 </span>            : #define LOG_TO_STRING_WARNING(message) google::LogMessage( \
<span class="lineNum">     391 </span>            :       __FILE__, __LINE__, google::GLOG_WARNING, message)
<span class="lineNum">     392 </span>            : #else
<span class="lineNum">     393 </span>            : #define COMPACT_GOOGLE_LOG_WARNING google::NullStream()
<span class="lineNum">     394 </span>            : #define LOG_TO_STRING_WARNING(message) google::NullStream()
<span class="lineNum">     395 </span>            : #endif
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : #if GOOGLE_STRIP_LOG &lt;= 2
<span class="lineNum">     398 </span>            : #define COMPACT_GOOGLE_LOG_ERROR google::LogMessage( \
<span class="lineNum">     399 </span>            :       __FILE__, __LINE__, google::GLOG_ERROR)
<span class="lineNum">     400 </span>            : #define LOG_TO_STRING_ERROR(message) google::LogMessage( \
<span class="lineNum">     401 </span>            :       __FILE__, __LINE__, google::GLOG_ERROR, message)
<span class="lineNum">     402 </span>            : #else
<span class="lineNum">     403 </span>            : #define COMPACT_GOOGLE_LOG_ERROR google::NullStream()
<span class="lineNum">     404 </span>            : #define LOG_TO_STRING_ERROR(message) google::NullStream()
<span class="lineNum">     405 </span>            : #endif
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            : #if GOOGLE_STRIP_LOG &lt;= 3
<span class="lineNum">     408 </span>            : #define COMPACT_GOOGLE_LOG_FATAL google::LogMessageFatal( \
<span class="lineNum">     409 </span>            :       __FILE__, __LINE__)
<span class="lineNum">     410 </span>            : #define LOG_TO_STRING_FATAL(message) google::LogMessage( \
<span class="lineNum">     411 </span>            :       __FILE__, __LINE__, google::GLOG_FATAL, message)
<span class="lineNum">     412 </span>            : #else
<span class="lineNum">     413 </span>            : #define COMPACT_GOOGLE_LOG_FATAL google::NullStreamFatal()
<span class="lineNum">     414 </span>            : #define LOG_TO_STRING_FATAL(message) google::NullStreamFatal()
<span class="lineNum">     415 </span>            : #endif
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : // For DFATAL, we want to use LogMessage (as opposed to
<span class="lineNum">     418 </span>            : // LogMessageFatal), to be consistent with the original behavior.
<span class="lineNum">     419 </span>            : #ifdef NDEBUG
<span class="lineNum">     420 </span>            : #define COMPACT_GOOGLE_LOG_DFATAL COMPACT_GOOGLE_LOG_ERROR
<span class="lineNum">     421 </span>            : #elif GOOGLE_STRIP_LOG &lt;= 3
<span class="lineNum">     422 </span>            : #define COMPACT_GOOGLE_LOG_DFATAL google::LogMessage( \
<span class="lineNum">     423 </span>            :       __FILE__, __LINE__, google::GLOG_FATAL)
<span class="lineNum">     424 </span>            : #else
<span class="lineNum">     425 </span>            : #define COMPACT_GOOGLE_LOG_DFATAL google::NullStreamFatal()
<span class="lineNum">     426 </span>            : #endif
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : #define GOOGLE_LOG_INFO(counter) google::LogMessage(__FILE__, __LINE__, google::GLOG_INFO, counter, &amp;google::LogMessage::SendToLog)
<span class="lineNum">     429 </span>            : #define SYSLOG_INFO(counter) \
<span class="lineNum">     430 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_INFO, counter, \
<span class="lineNum">     431 </span>            :   &amp;google::LogMessage::SendToSyslogAndLog)
<span class="lineNum">     432 </span>            : #define GOOGLE_LOG_WARNING(counter)  \
<span class="lineNum">     433 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_WARNING, counter, \
<span class="lineNum">     434 </span>            :   &amp;google::LogMessage::SendToLog)
<span class="lineNum">     435 </span>            : #define SYSLOG_WARNING(counter)  \
<span class="lineNum">     436 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_WARNING, counter, \
<span class="lineNum">     437 </span>            :   &amp;google::LogMessage::SendToSyslogAndLog)
<span class="lineNum">     438 </span>            : #define GOOGLE_LOG_ERROR(counter)  \
<span class="lineNum">     439 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, counter, \
<span class="lineNum">     440 </span>            :   &amp;google::LogMessage::SendToLog)
<span class="lineNum">     441 </span>            : #define SYSLOG_ERROR(counter)  \
<span class="lineNum">     442 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, counter, \
<span class="lineNum">     443 </span>            :   &amp;google::LogMessage::SendToSyslogAndLog)
<span class="lineNum">     444 </span>            : #define GOOGLE_LOG_FATAL(counter) \
<span class="lineNum">     445 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_FATAL, counter, \
<span class="lineNum">     446 </span>            :   &amp;google::LogMessage::SendToLog)
<span class="lineNum">     447 </span>            : #define SYSLOG_FATAL(counter) \
<span class="lineNum">     448 </span>            :   google::LogMessage(__FILE__, __LINE__, google::GLOG_FATAL, counter, \
<span class="lineNum">     449 </span>            :   &amp;google::LogMessage::SendToSyslogAndLog)
<span class="lineNum">     450 </span>            : #define GOOGLE_LOG_DFATAL(counter) \
<span class="lineNum">     451 </span>            :   google::LogMessage(__FILE__, __LINE__, google::DFATAL_LEVEL, counter, \
<span class="lineNum">     452 </span>            :   &amp;google::LogMessage::SendToLog)
<span class="lineNum">     453 </span>            : #define SYSLOG_DFATAL(counter) \
<span class="lineNum">     454 </span>            :   google::LogMessage(__FILE__, __LINE__, google::DFATAL_LEVEL, counter, \
<span class="lineNum">     455 </span>            :   &amp;google::LogMessage::SendToSyslogAndLog)
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : #if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__) || defined(__CYGWIN32__)
<span class="lineNum">     458 </span>            : // A very useful logging macro to log windows errors:
<span class="lineNum">     459 </span>            : #define LOG_SYSRESULT(result) \
<span class="lineNum">     460 </span>            :   if (FAILED(HRESULT_FROM_WIN32(result))) { \
<span class="lineNum">     461 </span>            :     LPSTR message = NULL; \
<span class="lineNum">     462 </span>            :     LPSTR msg = reinterpret_cast&lt;LPSTR&gt;(&amp;message); \
<span class="lineNum">     463 </span>            :     DWORD message_length = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | \
<span class="lineNum">     464 </span>            :                          FORMAT_MESSAGE_FROM_SYSTEM, \
<span class="lineNum">     465 </span>            :                          0, result, 0, msg, 100, NULL); \
<span class="lineNum">     466 </span>            :     if (message_length &gt; 0) { \
<span class="lineNum">     467 </span>            :       google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, 0, \
<span class="lineNum">     468 </span>            :           &amp;google::LogMessage::SendToLog).stream() \
<span class="lineNum">     469 </span>            :           &lt;&lt; reinterpret_cast&lt;const char*&gt;(message); \
<span class="lineNum">     470 </span>            :       LocalFree(message); \
<span class="lineNum">     471 </span>            :     } \
<span class="lineNum">     472 </span>            :   }
<span class="lineNum">     473 </span>            : #endif
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : // We use the preprocessor's merging operator, &quot;##&quot;, so that, e.g.,
<span class="lineNum">     476 </span>            : // LOG(INFO) becomes the token GOOGLE_LOG_INFO.  There's some funny
<span class="lineNum">     477 </span>            : // subtle difference between ostream member streaming functions (e.g.,
<span class="lineNum">     478 </span>            : // ostream::operator&lt;&lt;(int) and ostream non-member streaming functions
<span class="lineNum">     479 </span>            : // (e.g., ::operator&lt;&lt;(ostream&amp;, string&amp;): it turns out that it's
<span class="lineNum">     480 </span>            : // impossible to stream something like a string directly to an unnamed
<span class="lineNum">     481 </span>            : // ostream. We employ a neat hack by calling the stream() member
<span class="lineNum">     482 </span>            : // function of LogMessage which seems to avoid the problem.
<span class="lineNum">     483 </span>            : #define LOG(severity) COMPACT_GOOGLE_LOG_ ## severity.stream()
<span class="lineNum">     484 </span>            : #define SYSLOG(severity) SYSLOG_ ## severity(0).stream()
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : namespace google {
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : // They need the definitions of integer types.
<span class="lineNum">     489 </span>            : #include &quot;glog/log_severity.h&quot;
<span class="lineNum">     490 </span>            : #include &quot;glog/vlog_is_on.h&quot;
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            : // Initialize google's logging library. You will see the program name
<span class="lineNum">     493 </span>            : // specified by argv0 in log outputs.
<span class="lineNum">     494 </span>            : GOOGLE_GLOG_DLL_DECL void InitGoogleLogging(const char* argv0);
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : // Shutdown google's logging library.
<span class="lineNum">     497 </span>            : GOOGLE_GLOG_DLL_DECL void ShutdownGoogleLogging();
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            : // Install a function which will be called after LOG(FATAL).
<span class="lineNum">     500 </span>            : GOOGLE_GLOG_DLL_DECL void InstallFailureFunction(void (*fail_func)());
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : class LogSink;  // defined below
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : // If a non-NULL sink pointer is given, we push this message to that sink.
<span class="lineNum">     505 </span>            : // For LOG_TO_SINK we then do normal LOG(severity) logging as well.
<span class="lineNum">     506 </span>            : // This is useful for capturing messages and passing/storing them
<span class="lineNum">     507 </span>            : // somewhere more specific than the global log of the process.
<span class="lineNum">     508 </span>            : // Argument types:
<span class="lineNum">     509 </span>            : //   LogSink* sink;
<span class="lineNum">     510 </span>            : //   LogSeverity severity;
<span class="lineNum">     511 </span>            : // The cast is to disambiguate NULL arguments.
<span class="lineNum">     512 </span>            : #define LOG_TO_SINK(sink, severity) \
<span class="lineNum">     513 </span>            :   google::LogMessage(                                    \
<span class="lineNum">     514 </span>            :       __FILE__, __LINE__,                                               \
<span class="lineNum">     515 </span>            :       google::GLOG_ ## severity,                         \
<span class="lineNum">     516 </span>            :       static_cast&lt;google::LogSink*&gt;(sink), true).stream()
<span class="lineNum">     517 </span>            : #define LOG_TO_SINK_BUT_NOT_TO_LOGFILE(sink, severity)                  \
<span class="lineNum">     518 </span>            :   google::LogMessage(                                    \
<span class="lineNum">     519 </span>            :       __FILE__, __LINE__,                                               \
<span class="lineNum">     520 </span>            :       google::GLOG_ ## severity,                         \
<span class="lineNum">     521 </span>            :       static_cast&lt;google::LogSink*&gt;(sink), false).stream()
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            : // If a non-NULL string pointer is given, we write this message to that string.
<span class="lineNum">     524 </span>            : // We then do normal LOG(severity) logging as well.
<span class="lineNum">     525 </span>            : // This is useful for capturing messages and storing them somewhere more
<span class="lineNum">     526 </span>            : // specific than the global log of the process.
<span class="lineNum">     527 </span>            : // Argument types:
<span class="lineNum">     528 </span>            : //   string* message;
<span class="lineNum">     529 </span>            : //   LogSeverity severity;
<span class="lineNum">     530 </span>            : // The cast is to disambiguate NULL arguments.
<span class="lineNum">     531 </span>            : // NOTE: LOG(severity) expands to LogMessage().stream() for the specified
<span class="lineNum">     532 </span>            : // severity.
<span class="lineNum">     533 </span>            : #define LOG_TO_STRING(severity, message) \
<span class="lineNum">     534 </span>            :   LOG_TO_STRING_##severity(static_cast&lt;string*&gt;(message)).stream()
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : // If a non-NULL pointer is given, we push the message onto the end
<span class="lineNum">     537 </span>            : // of a vector of strings; otherwise, we report it with LOG(severity).
<span class="lineNum">     538 </span>            : // This is handy for capturing messages and perhaps passing them back
<span class="lineNum">     539 </span>            : // to the caller, rather than reporting them immediately.
<span class="lineNum">     540 </span>            : // Argument types:
<span class="lineNum">     541 </span>            : //   LogSeverity severity;
<span class="lineNum">     542 </span>            : //   vector&lt;string&gt; *outvec;
<span class="lineNum">     543 </span>            : // The cast is to disambiguate NULL arguments.
<span class="lineNum">     544 </span>            : #define LOG_STRING(severity, outvec) \
<span class="lineNum">     545 </span>            :   LOG_TO_STRING_##severity(static_cast&lt;vector&lt;string&gt;*&gt;(outvec)).stream()
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : #define LOG_IF(severity, condition) \
<span class="lineNum">     548 </span>            :   !(condition) ? (void) 0 : google::LogMessageVoidify() &amp; LOG(severity)
<span class="lineNum">     549 </span>            : #define SYSLOG_IF(severity, condition) \
<span class="lineNum">     550 </span>            :   !(condition) ? (void) 0 : google::LogMessageVoidify() &amp; SYSLOG(severity)
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : #define LOG_ASSERT(condition)  \
<span class="lineNum">     553 </span>            :   LOG_IF(FATAL, !(condition)) &lt;&lt; &quot;Assert failed: &quot; #condition
<span class="lineNum">     554 </span>            : #define SYSLOG_ASSERT(condition) \
<span class="lineNum">     555 </span>            :   SYSLOG_IF(FATAL, !(condition)) &lt;&lt; &quot;Assert failed: &quot; #condition
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : // CHECK dies with a fatal error if condition is not true.  It is *not*
<span class="lineNum">     558 </span>            : // controlled by NDEBUG, so the check will be executed regardless of
<span class="lineNum">     559 </span>            : // compilation mode.  Therefore, it is safe to do things like:
<span class="lineNum">     560 </span>            : //    CHECK(fp-&gt;Write(x) == 4)
<span class="lineNum">     561 </span>            : #define CHECK(condition)  \
<span class="lineNum">     562 </span>            :       LOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN(!(condition))) \
<span class="lineNum">     563 </span>            :              &lt;&lt; &quot;Check failed: &quot; #condition &quot; &quot;
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : // A container for a string pointer which can be evaluated to a bool -
<a name="566"><span class="lineNum">     566 </span>            : // true iff the pointer is NULL.</a>
<span class="lineNum">     567 </span>            : struct CheckOpString {
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   CheckOpString(std::string* str) : str_(str) { }</span>
<span class="lineNum">     569 </span>            :   // No destructor: if str_ is non-NULL, we're about to LOG(FATAL),
<span class="lineNum">     570 </span>            :   // so there's no point in cleaning up str_.
<span class="lineNum">     571 </span>            :   operator bool() const {
<span class="lineNum">     572 </span>            :     return GOOGLE_PREDICT_BRANCH_NOT_TAKEN(str_ != NULL);
<span class="lineNum">     573 </span>            :   }
<span class="lineNum">     574 </span>            :   std::string* str_;
<span class="lineNum">     575 </span>            : };
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : // Function is overloaded for integral types to allow static const
<span class="lineNum">     578 </span>            : // integrals declared in classes and not defined to be used as arguments to
<a name="579"><span class="lineNum">     579 </span>            : // CHECK* macros. It's not encouraged though.</a>
<span class="lineNum">     580 </span>            : template &lt;class T&gt;
<span class="lineNum">     581 </span><span class="lineNoCov">          0 : inline const T&amp;       GetReferenceableValue(const T&amp;           t) { return t; }</span>
<span class="lineNum">     582 </span>            : inline char           GetReferenceableValue(char               t) { return t; }
<span class="lineNum">     583 </span>            : inline unsigned char  GetReferenceableValue(unsigned char      t) { return t; }
<span class="lineNum">     584 </span>            : inline signed char    GetReferenceableValue(signed char        t) { return t; }
<a name="585"><span class="lineNum">     585 </span>            : inline short          GetReferenceableValue(short              t) { return t; }</a>
<span class="lineNum">     586 </span>            : inline unsigned short GetReferenceableValue(unsigned short     t) { return t; }
<span class="lineNum">     587 </span><span class="lineNoCov">          0 : inline int            GetReferenceableValue(int                t) { return t; }</span>
<span class="lineNum">     588 </span>            : inline unsigned int   GetReferenceableValue(unsigned int       t) { return t; }
<span class="lineNum">     589 </span>            : inline long           GetReferenceableValue(long               t) { return t; }
<span class="lineNum">     590 </span>            : inline unsigned long  GetReferenceableValue(unsigned long      t) { return t; }
<span class="lineNum">     591 </span>            : inline long long      GetReferenceableValue(long long          t) { return t; }
<span class="lineNum">     592 </span>            : inline unsigned long long GetReferenceableValue(unsigned long long t) {
<span class="lineNum">     593 </span>            :   return t;
<span class="lineNum">     594 </span>            : }
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            : // This is a dummy class to define the following operator.
<span class="lineNum">     597 </span>            : struct DummyClassToDefineOperator {};
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            : }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : // Define global operator&lt;&lt; to declare using ::operator&lt;&lt;.
<span class="lineNum">     602 </span>            : // This declaration will allow use to use CHECK macros for user
<span class="lineNum">     603 </span>            : // defined classes which have operator&lt;&lt; (e.g., stl_logging.h).
<span class="lineNum">     604 </span>            : inline std::ostream&amp; operator&lt;&lt;(
<span class="lineNum">     605 </span>            :     std::ostream&amp; out, const google::DummyClassToDefineOperator&amp;) {
<span class="lineNum">     606 </span>            :   return out;
<span class="lineNum">     607 </span>            : }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : namespace google {
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : // This formats a value for a failing CHECK_XX statement.  Ordinarily,
<a name="612"><span class="lineNum">     612 </span>            : // it uses the definition for operator&lt;&lt;, with a few special cases below.</a>
<span class="lineNum">     613 </span>            : template &lt;typename T&gt;
<span class="lineNum">     614 </span><span class="lineNoCov">          0 : inline void MakeCheckOpValueString(std::ostream* os, const T&amp; v) {</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   (*os) &lt;&lt; v;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            : // Overrides for char types provide readable values for unprintable
<span class="lineNum">     619 </span>            : // characters.
<span class="lineNum">     620 </span>            : template &lt;&gt; GOOGLE_GLOG_DLL_DECL
<span class="lineNum">     621 </span>            : void MakeCheckOpValueString(std::ostream* os, const char&amp; v);
<span class="lineNum">     622 </span>            : template &lt;&gt; GOOGLE_GLOG_DLL_DECL
<span class="lineNum">     623 </span>            : void MakeCheckOpValueString(std::ostream* os, const signed char&amp; v);
<span class="lineNum">     624 </span>            : template &lt;&gt; GOOGLE_GLOG_DLL_DECL
<span class="lineNum">     625 </span>            : void MakeCheckOpValueString(std::ostream* os, const unsigned char&amp; v);
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : // Build the error message string. Specify no inlining for code size.
<span class="lineNum">     628 </span>            : template &lt;typename T1, typename T2&gt;
<span class="lineNum">     629 </span>            : std::string* MakeCheckOpString(const T1&amp; v1, const T2&amp; v2, const char* exprtext)
<span class="lineNum">     630 </span>            :     __attribute__ ((noinline));
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : namespace base {
<span class="lineNum">     633 </span>            : namespace internal {
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            : // If &quot;s&quot; is less than base_logging::INFO, returns base_logging::INFO.
<span class="lineNum">     636 </span>            : // If &quot;s&quot; is greater than base_logging::FATAL, returns
<span class="lineNum">     637 </span>            : // base_logging::ERROR.  Otherwise, returns &quot;s&quot;.
<span class="lineNum">     638 </span>            : LogSeverity NormalizeSeverity(LogSeverity s);
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            : }  // namespace internal
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : // A helper class for formatting &quot;expr (V1 vs. V2)&quot; in a CHECK_XX
<span class="lineNum">     643 </span>            : // statement.  See MakeCheckOpString for sample usage.  Other
<span class="lineNum">     644 </span>            : // approaches were considered: use of a template method (e.g.,
<span class="lineNum">     645 </span>            : // base::BuildCheckOpString(exprtext, base::Print&lt;T1&gt;, &amp;v1,
<span class="lineNum">     646 </span>            : // base::Print&lt;T2&gt;, &amp;v2), however this approach has complications
<span class="lineNum">     647 </span>            : // related to volatile arguments and function-pointer arguments).
<span class="lineNum">     648 </span>            : class GOOGLE_GLOG_DLL_DECL CheckOpMessageBuilder {
<span class="lineNum">     649 </span>            :  public:
<span class="lineNum">     650 </span>            :   // Inserts &quot;exprtext&quot; and &quot; (&quot; to the stream.
<span class="lineNum">     651 </span>            :   explicit CheckOpMessageBuilder(const char *exprtext);
<span class="lineNum">     652 </span>            :   // Deletes &quot;stream_&quot;.
<a name="653"><span class="lineNum">     653 </span>            :   ~CheckOpMessageBuilder();</a>
<span class="lineNum">     654 </span>            :   // For inserting the first variable.
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   std::ostream* ForVar1() { return stream_; }</span>
<span class="lineNum">     656 </span>            :   // For inserting the second variable (adds an intermediate &quot; vs. &quot;).
<span class="lineNum">     657 </span>            :   std::ostream* ForVar2();
<span class="lineNum">     658 </span>            :   // Get the result (inserts the closing &quot;)&quot;).
<span class="lineNum">     659 </span>            :   std::string* NewString();
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :  private:
<span class="lineNum">     662 </span>            :   std::ostringstream *stream_;
<span class="lineNum">     663 </span>            : };
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : }  // namespace base
<a name="666"><span class="lineNum">     666 </span>            : </a>
<span class="lineNum">     667 </span>            : template &lt;typename T1, typename T2&gt;
<span class="lineNum">     668 </span><span class="lineNoCov">          0 : std::string* MakeCheckOpString(const T1&amp; v1, const T2&amp; v2, const char* exprtext) {</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   base::CheckOpMessageBuilder comb(exprtext);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   MakeCheckOpValueString(comb.ForVar1(), v1);</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :   MakeCheckOpValueString(comb.ForVar2(), v2);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   return comb.NewString();</span>
<span class="lineNum">     673 </span>            : }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            : // Helper functions for CHECK_OP macro.
<span class="lineNum">     676 </span>            : // The (int, int) specialization works around the issue that the compiler
<span class="lineNum">     677 </span>            : // will not instantiate the template version of the function on values of
<span class="lineNum">     678 </span>            : // unnamed enum type - see comment below.
<span class="lineNum">     679 </span>            : #define DEFINE_CHECK_OP_IMPL(name, op) \
<span class="lineNum">     680 </span>            :   template &lt;typename T1, typename T2&gt; \
<span class="lineNum">     681 </span>            :   inline std::string* name##Impl(const T1&amp; v1, const T2&amp; v2,    \
<span class="lineNum">     682 </span>            :                             const char* exprtext) { \
<span class="lineNum">     683 </span>            :     if (GOOGLE_PREDICT_TRUE(v1 op v2)) return NULL; \
<span class="lineNum">     684 </span>            :     else return MakeCheckOpString(v1, v2, exprtext); \
<span class="lineNum">     685 </span>            :   } \
<span class="lineNum">     686 </span>            :   inline std::string* name##Impl(int v1, int v2, const char* exprtext) { \
<span class="lineNum">     687 </span>            :     return name##Impl&lt;int, int&gt;(v1, v2, exprtext); \
<span class="lineNum">     688 </span>            :   }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : // We use the full name Check_EQ, Check_NE, etc. in case the file including
<span class="lineNum">     691 </span>            : // base/logging.h provides its own #defines for the simpler names EQ, NE, etc.
<a name="692"><span class="lineNum">     692 </span>            : // This happens if, for example, those are used as token names in a</a>
<span class="lineNum">     693 </span>            : // yacc grammar.
<span class="lineNum">     694 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(Check_EQ, ==)  // Compilation error with CHECK_EQ(NULL, x)?</span>
<a name="695"><span class="lineNum">     695 </span>            : DEFINE_CHECK_OP_IMPL(Check_NE, !=)  // Use CHECK(x == NULL) instead.</a>
<a name="696"><span class="lineNum">     696 </span>            : DEFINE_CHECK_OP_IMPL(Check_LE, &lt;=)</a>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(Check_LT, &lt; )</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(Check_GE, &gt;=)</span>
<span class="lineNum">     699 </span>            : DEFINE_CHECK_OP_IMPL(Check_GT, &gt; )
<span class="lineNum">     700 </span>            : #undef DEFINE_CHECK_OP_IMPL
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : // Helper macro for binary operators.
<span class="lineNum">     703 </span>            : // Don't use this macro directly in your code, use CHECK_EQ et al below.
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : #if defined(STATIC_ANALYSIS)
<span class="lineNum">     706 </span>            : // Only for static analysis tool to know that it is equivalent to assert
<span class="lineNum">     707 </span>            : #define CHECK_OP_LOG(name, op, val1, val2, log) CHECK((val1) op (val2))
<span class="lineNum">     708 </span>            : #elif !defined(NDEBUG)
<span class="lineNum">     709 </span>            : // In debug mode, avoid constructing CheckOpStrings if possible,
<span class="lineNum">     710 </span>            : // to reduce the overhead of CHECK statments by 2x.
<span class="lineNum">     711 </span>            : // Real DCHECK-heavy tests have seen 1.5x speedups.
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : // The meaning of &quot;string&quot; might be different between now and 
<span class="lineNum">     714 </span>            : // when this macro gets invoked (e.g., if someone is experimenting
<span class="lineNum">     715 </span>            : // with other string implementations that get defined after this
<span class="lineNum">     716 </span>            : // file is included).  Save the current meaning now and use it 
<span class="lineNum">     717 </span>            : // in the macro.
<span class="lineNum">     718 </span>            : typedef std::string _Check_string;
<span class="lineNum">     719 </span>            : #define CHECK_OP_LOG(name, op, val1, val2, log)                         \
<span class="lineNum">     720 </span>            :   while (google::_Check_string* _result =                \
<span class="lineNum">     721 </span>            :          google::Check##name##Impl(                      \
<span class="lineNum">     722 </span>            :              google::GetReferenceableValue(val1),        \
<span class="lineNum">     723 </span>            :              google::GetReferenceableValue(val2),        \
<span class="lineNum">     724 </span>            :              #val1 &quot; &quot; #op &quot; &quot; #val2))                                  \
<span class="lineNum">     725 </span>            :     log(__FILE__, __LINE__,                                             \
<span class="lineNum">     726 </span>            :         google::CheckOpString(_result)).stream()
<span class="lineNum">     727 </span>            : #else
<span class="lineNum">     728 </span>            : // In optimized mode, use CheckOpString to hint to compiler that
<span class="lineNum">     729 </span>            : // the while condition is unlikely.
<span class="lineNum">     730 </span>            : #define CHECK_OP_LOG(name, op, val1, val2, log)                         \
<span class="lineNum">     731 </span>            :   while (google::CheckOpString _result =                 \
<span class="lineNum">     732 </span>            :          google::Check##name##Impl(                      \
<span class="lineNum">     733 </span>            :              google::GetReferenceableValue(val1),        \
<span class="lineNum">     734 </span>            :              google::GetReferenceableValue(val2),        \
<span class="lineNum">     735 </span>            :              #val1 &quot; &quot; #op &quot; &quot; #val2))                                  \
<span class="lineNum">     736 </span>            :     log(__FILE__, __LINE__, _result).stream()
<span class="lineNum">     737 </span>            : #endif  // STATIC_ANALYSIS, !NDEBUG
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : #if GOOGLE_STRIP_LOG &lt;= 3
<span class="lineNum">     740 </span>            : #define CHECK_OP(name, op, val1, val2) \
<span class="lineNum">     741 </span>            :   CHECK_OP_LOG(name, op, val1, val2, google::LogMessageFatal)
<span class="lineNum">     742 </span>            : #else
<span class="lineNum">     743 </span>            : #define CHECK_OP(name, op, val1, val2) \
<span class="lineNum">     744 </span>            :   CHECK_OP_LOG(name, op, val1, val2, google::NullStreamFatal)
<span class="lineNum">     745 </span>            : #endif // STRIP_LOG &lt;= 3
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : // Equality/Inequality checks - compare two values, and log a FATAL message
<span class="lineNum">     748 </span>            : // including the two values when the result is not as expected.  The values
<span class="lineNum">     749 </span>            : // must have operator&lt;&lt;(ostream, ...) defined.
<span class="lineNum">     750 </span>            : //
<span class="lineNum">     751 </span>            : // You may append to the error message like so:
<span class="lineNum">     752 </span>            : //   CHECK_NE(1, 2) &lt;&lt; &quot;: The world must be ending!&quot;;
<span class="lineNum">     753 </span>            : //
<span class="lineNum">     754 </span>            : // We are very careful to ensure that each argument is evaluated exactly
<span class="lineNum">     755 </span>            : // once, and that anything which is legal to pass as a function argument is
<span class="lineNum">     756 </span>            : // legal here.  In particular, the arguments may be temporary expressions
<span class="lineNum">     757 </span>            : // which will end up being destroyed at the end of the apparent statement,
<span class="lineNum">     758 </span>            : // for example:
<span class="lineNum">     759 </span>            : //   CHECK_EQ(string(&quot;abc&quot;)[1], 'b');
<span class="lineNum">     760 </span>            : //
<span class="lineNum">     761 </span>            : // WARNING: These don't compile correctly if one of the arguments is a pointer
<span class="lineNum">     762 </span>            : // and the other is NULL. To work around this, simply static_cast NULL to the
<span class="lineNum">     763 </span>            : // type of the desired pointer.
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : #define CHECK_EQ(val1, val2) CHECK_OP(_EQ, ==, val1, val2)
<span class="lineNum">     766 </span>            : #define CHECK_NE(val1, val2) CHECK_OP(_NE, !=, val1, val2)
<span class="lineNum">     767 </span>            : #define CHECK_LE(val1, val2) CHECK_OP(_LE, &lt;=, val1, val2)
<span class="lineNum">     768 </span>            : #define CHECK_LT(val1, val2) CHECK_OP(_LT, &lt; , val1, val2)
<span class="lineNum">     769 </span>            : #define CHECK_GE(val1, val2) CHECK_OP(_GE, &gt;=, val1, val2)
<span class="lineNum">     770 </span>            : #define CHECK_GT(val1, val2) CHECK_OP(_GT, &gt; , val1, val2)
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            : // Check that the input is non NULL.  This very useful in constructor
<span class="lineNum">     773 </span>            : // initializer lists.
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : #define CHECK_NOTNULL(val) \
<span class="lineNum">     776 </span>            :   google::CheckNotNull(__FILE__, __LINE__, &quot;'&quot; #val &quot;' Must be non NULL&quot;, (val))
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : // Helper functions for string comparisons.
<span class="lineNum">     779 </span>            : // To avoid bloat, the definitions are in logging.cc.
<span class="lineNum">     780 </span>            : #define DECLARE_CHECK_STROP_IMPL(func, expected) \
<span class="lineNum">     781 </span>            :   GOOGLE_GLOG_DLL_DECL std::string* Check##func##expected##Impl( \
<span class="lineNum">     782 </span>            :       const char* s1, const char* s2, const char* names);
<span class="lineNum">     783 </span>            : DECLARE_CHECK_STROP_IMPL(strcmp, true)
<span class="lineNum">     784 </span>            : DECLARE_CHECK_STROP_IMPL(strcmp, false)
<span class="lineNum">     785 </span>            : DECLARE_CHECK_STROP_IMPL(strcasecmp, true)
<span class="lineNum">     786 </span>            : DECLARE_CHECK_STROP_IMPL(strcasecmp, false)
<span class="lineNum">     787 </span>            : #undef DECLARE_CHECK_STROP_IMPL
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            : // Helper macro for string comparisons.
<span class="lineNum">     790 </span>            : // Don't use this macro directly in your code, use CHECK_STREQ et al below.
<span class="lineNum">     791 </span>            : #define CHECK_STROP(func, op, expected, s1, s2) \
<span class="lineNum">     792 </span>            :   while (google::CheckOpString _result = \
<span class="lineNum">     793 </span>            :          google::Check##func##expected##Impl((s1), (s2), \
<span class="lineNum">     794 </span>            :                                      #s1 &quot; &quot; #op &quot; &quot; #s2)) \
<span class="lineNum">     795 </span>            :     LOG(FATAL) &lt;&lt; *_result.str_
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : // String (char*) equality/inequality checks.
<span class="lineNum">     799 </span>            : // CASE versions are case-insensitive.
<span class="lineNum">     800 </span>            : //
<span class="lineNum">     801 </span>            : // Note that &quot;s1&quot; and &quot;s2&quot; may be temporary strings which are destroyed
<span class="lineNum">     802 </span>            : // by the compiler at the end of the current &quot;full expression&quot;
<span class="lineNum">     803 </span>            : // (e.g. CHECK_STREQ(Foo().c_str(), Bar().c_str())).
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            : #define CHECK_STREQ(s1, s2) CHECK_STROP(strcmp, ==, true, s1, s2)
<span class="lineNum">     806 </span>            : #define CHECK_STRNE(s1, s2) CHECK_STROP(strcmp, !=, false, s1, s2)
<span class="lineNum">     807 </span>            : #define CHECK_STRCASEEQ(s1, s2) CHECK_STROP(strcasecmp, ==, true, s1, s2)
<span class="lineNum">     808 </span>            : #define CHECK_STRCASENE(s1, s2) CHECK_STROP(strcasecmp, !=, false, s1, s2)
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : #define CHECK_INDEX(I,A) CHECK(I &lt; (sizeof(A)/sizeof(A[0])))
<span class="lineNum">     811 </span>            : #define CHECK_BOUND(B,A) CHECK(B &lt;= (sizeof(A)/sizeof(A[0])))
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            : #define CHECK_DOUBLE_EQ(val1, val2)              \
<span class="lineNum">     814 </span>            :   do {                                           \
<span class="lineNum">     815 </span>            :     CHECK_LE((val1), (val2)+0.000000000000001L); \
<span class="lineNum">     816 </span>            :     CHECK_GE((val1), (val2)-0.000000000000001L); \
<span class="lineNum">     817 </span>            :   } while (0)
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            : #define CHECK_NEAR(val1, val2, margin)           \
<span class="lineNum">     820 </span>            :   do {                                           \
<span class="lineNum">     821 </span>            :     CHECK_LE((val1), (val2)+(margin));           \
<span class="lineNum">     822 </span>            :     CHECK_GE((val1), (val2)-(margin));           \
<span class="lineNum">     823 </span>            :   } while (0)
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : // perror()..googly style!
<span class="lineNum">     826 </span>            : //
<span class="lineNum">     827 </span>            : // PLOG() and PLOG_IF() and PCHECK() behave exactly like their LOG* and
<span class="lineNum">     828 </span>            : // CHECK equivalents with the addition that they postpend a description
<span class="lineNum">     829 </span>            : // of the current state of errno to their output lines.
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            : #define PLOG(severity) GOOGLE_PLOG(severity, 0).stream()
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : #define GOOGLE_PLOG(severity, counter)  \
<span class="lineNum">     834 </span>            :   google::ErrnoLogMessage( \
<span class="lineNum">     835 </span>            :       __FILE__, __LINE__, google::GLOG_ ## severity, counter, \
<span class="lineNum">     836 </span>            :       &amp;google::LogMessage::SendToLog)
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : #define PLOG_IF(severity, condition) \
<span class="lineNum">     839 </span>            :   !(condition) ? (void) 0 : google::LogMessageVoidify() &amp; PLOG(severity)
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            : // A CHECK() macro that postpends errno if the condition is false. E.g.
<span class="lineNum">     842 </span>            : //
<span class="lineNum">     843 </span>            : // if (poll(fds, nfds, timeout) == -1) { PCHECK(errno == EINTR); ... }
<span class="lineNum">     844 </span>            : #define PCHECK(condition)  \
<span class="lineNum">     845 </span>            :       PLOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN(!(condition))) \
<span class="lineNum">     846 </span>            :               &lt;&lt; &quot;Check failed: &quot; #condition &quot; &quot;
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : // A CHECK() macro that lets you assert the success of a function that
<span class="lineNum">     849 </span>            : // returns -1 and sets errno in case of an error. E.g.
<span class="lineNum">     850 </span>            : //
<span class="lineNum">     851 </span>            : // CHECK_ERR(mkdir(path, 0700));
<span class="lineNum">     852 </span>            : //
<span class="lineNum">     853 </span>            : // or
<span class="lineNum">     854 </span>            : //
<span class="lineNum">     855 </span>            : // int fd = open(filename, flags); CHECK_ERR(fd) &lt;&lt; &quot;: open &quot; &lt;&lt; filename;
<span class="lineNum">     856 </span>            : #define CHECK_ERR(invocation)                                          \
<span class="lineNum">     857 </span>            : PLOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN((invocation) == -1))    \
<span class="lineNum">     858 </span>            :         &lt;&lt; #invocation
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : // Use macro expansion to create, for each use of LOG_EVERY_N(), static
<span class="lineNum">     861 </span>            : // variables with the __LINE__ expansion as part of the variable name.
<span class="lineNum">     862 </span>            : #define LOG_EVERY_N_VARNAME(base, line) LOG_EVERY_N_VARNAME_CONCAT(base, line)
<span class="lineNum">     863 </span>            : #define LOG_EVERY_N_VARNAME_CONCAT(base, line) base ## line
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            : #define LOG_OCCURRENCES LOG_EVERY_N_VARNAME(occurrences_, __LINE__)
<span class="lineNum">     866 </span>            : #define LOG_OCCURRENCES_MOD_N LOG_EVERY_N_VARNAME(occurrences_mod_n_, __LINE__)
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : #define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
<span class="lineNum">     869 </span>            :   static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
<span class="lineNum">     870 </span>            :   ++LOG_OCCURRENCES; \
<span class="lineNum">     871 </span>            :   if (++LOG_OCCURRENCES_MOD_N &gt; n) LOG_OCCURRENCES_MOD_N -= n; \
<span class="lineNum">     872 </span>            :   if (LOG_OCCURRENCES_MOD_N == 1) \
<span class="lineNum">     873 </span>            :     google::LogMessage( \
<span class="lineNum">     874 </span>            :         __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
<span class="lineNum">     875 </span>            :         &amp;what_to_do).stream()
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : #define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
<span class="lineNum">     878 </span>            :   static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
<span class="lineNum">     879 </span>            :   ++LOG_OCCURRENCES; \
<span class="lineNum">     880 </span>            :   if (condition &amp;&amp; \
<span class="lineNum">     881 </span>            :       ((LOG_OCCURRENCES_MOD_N=(LOG_OCCURRENCES_MOD_N + 1) % n) == (1 % n))) \
<span class="lineNum">     882 </span>            :     google::LogMessage( \
<span class="lineNum">     883 </span>            :         __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
<span class="lineNum">     884 </span>            :                  &amp;what_to_do).stream()
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            : #define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
<span class="lineNum">     887 </span>            :   static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
<span class="lineNum">     888 </span>            :   ++LOG_OCCURRENCES; \
<span class="lineNum">     889 </span>            :   if (++LOG_OCCURRENCES_MOD_N &gt; n) LOG_OCCURRENCES_MOD_N -= n; \
<span class="lineNum">     890 </span>            :   if (LOG_OCCURRENCES_MOD_N == 1) \
<span class="lineNum">     891 </span>            :     google::ErrnoLogMessage( \
<span class="lineNum">     892 </span>            :         __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
<span class="lineNum">     893 </span>            :         &amp;what_to_do).stream()
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span>            : #define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
<span class="lineNum">     896 </span>            :   static int LOG_OCCURRENCES = 0; \
<span class="lineNum">     897 </span>            :   if (LOG_OCCURRENCES &lt;= n) \
<span class="lineNum">     898 </span>            :     ++LOG_OCCURRENCES; \
<span class="lineNum">     899 </span>            :   if (LOG_OCCURRENCES &lt;= n) \
<span class="lineNum">     900 </span>            :     google::LogMessage( \
<span class="lineNum">     901 </span>            :         __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
<span class="lineNum">     902 </span>            :         &amp;what_to_do).stream()
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span>            : namespace glog_internal_namespace_ {
<span class="lineNum">     905 </span>            : template &lt;bool&gt;
<span class="lineNum">     906 </span>            : struct CompileAssert {
<span class="lineNum">     907 </span>            : };
<span class="lineNum">     908 </span>            : struct CrashReason;
<span class="lineNum">     909 </span>            : }  // namespace glog_internal_namespace_
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : #define GOOGLE_GLOG_COMPILE_ASSERT(expr, msg) \
<span class="lineNum">     912 </span>            :   typedef google::glog_internal_namespace_::CompileAssert&lt;(bool(expr))&gt; msg[bool(expr) ? 1 : -1]
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : #define LOG_EVERY_N(severity, n)                                        \
<span class="lineNum">     915 </span>            :   GOOGLE_GLOG_COMPILE_ASSERT(google::GLOG_ ## severity &lt; \
<span class="lineNum">     916 </span>            :                              google::NUM_SEVERITIES,     \
<span class="lineNum">     917 </span>            :                              INVALID_REQUESTED_LOG_SEVERITY);           \
<span class="lineNum">     918 </span>            :   SOME_KIND_OF_LOG_EVERY_N(severity, (n), google::LogMessage::SendToLog)
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            : #define SYSLOG_EVERY_N(severity, n) \
<span class="lineNum">     921 </span>            :   SOME_KIND_OF_LOG_EVERY_N(severity, (n), google::LogMessage::SendToSyslogAndLog)
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : #define PLOG_EVERY_N(severity, n) \
<span class="lineNum">     924 </span>            :   SOME_KIND_OF_PLOG_EVERY_N(severity, (n), google::LogMessage::SendToLog)
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : #define LOG_FIRST_N(severity, n) \
<span class="lineNum">     927 </span>            :   SOME_KIND_OF_LOG_FIRST_N(severity, (n), google::LogMessage::SendToLog)
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            : #define LOG_IF_EVERY_N(severity, condition, n) \
<span class="lineNum">     930 </span>            :   SOME_KIND_OF_LOG_IF_EVERY_N(severity, (condition), (n), google::LogMessage::SendToLog)
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            : // We want the special COUNTER value available for LOG_EVERY_X()'ed messages
<span class="lineNum">     933 </span>            : enum PRIVATE_Counter {COUNTER};
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : #ifdef GLOG_NO_ABBREVIATED_SEVERITIES
<span class="lineNum">     936 </span>            : // wingdi.h defines ERROR to be 0. When we call LOG(ERROR), it gets
<span class="lineNum">     937 </span>            : // substituted with 0, and it expands to COMPACT_GOOGLE_LOG_0. To allow us
<span class="lineNum">     938 </span>            : // to keep using this syntax, we define this macro to do the same thing
<span class="lineNum">     939 </span>            : // as COMPACT_GOOGLE_LOG_ERROR.
<span class="lineNum">     940 </span>            : #define COMPACT_GOOGLE_LOG_0 COMPACT_GOOGLE_LOG_ERROR
<span class="lineNum">     941 </span>            : #define SYSLOG_0 SYSLOG_ERROR
<span class="lineNum">     942 </span>            : #define LOG_TO_STRING_0 LOG_TO_STRING_ERROR
<span class="lineNum">     943 </span>            : // Needed for LOG_IS_ON(ERROR).
<span class="lineNum">     944 </span>            : const LogSeverity GLOG_0 = GLOG_ERROR;
<span class="lineNum">     945 </span>            : #else
<span class="lineNum">     946 </span>            : // Users may include windows.h after logging.h without
<span class="lineNum">     947 </span>            : // GLOG_NO_ABBREVIATED_SEVERITIES nor WIN32_LEAN_AND_MEAN.
<span class="lineNum">     948 </span>            : // For this case, we cannot detect if ERROR is defined before users
<span class="lineNum">     949 </span>            : // actually use ERROR. Let's make an undefined symbol to warn users.
<span class="lineNum">     950 </span>            : # define GLOG_ERROR_MSG ERROR_macro_is_defined_Define_GLOG_NO_ABBREVIATED_SEVERITIES_before_including_logging_h_See_the_document_for_detail
<span class="lineNum">     951 </span>            : # define COMPACT_GOOGLE_LOG_0 GLOG_ERROR_MSG
<span class="lineNum">     952 </span>            : # define SYSLOG_0 GLOG_ERROR_MSG
<span class="lineNum">     953 </span>            : # define LOG_TO_STRING_0 GLOG_ERROR_MSG
<span class="lineNum">     954 </span>            : # define GLOG_0 GLOG_ERROR_MSG
<span class="lineNum">     955 </span>            : #endif
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            : // Plus some debug-logging macros that get compiled to nothing for production
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : #ifndef NDEBUG
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            : #define DLOG(severity) LOG(severity)
<span class="lineNum">     962 </span>            : #define DVLOG(verboselevel) VLOG(verboselevel)
<span class="lineNum">     963 </span>            : #define DLOG_IF(severity, condition) LOG_IF(severity, condition)
<span class="lineNum">     964 </span>            : #define DLOG_EVERY_N(severity, n) LOG_EVERY_N(severity, n)
<span class="lineNum">     965 </span>            : #define DLOG_IF_EVERY_N(severity, condition, n) \
<span class="lineNum">     966 </span>            :   LOG_IF_EVERY_N(severity, condition, n)
<span class="lineNum">     967 </span>            : #define DLOG_ASSERT(condition) LOG_ASSERT(condition)
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : // debug-only checking.  not executed in NDEBUG mode.
<span class="lineNum">     970 </span>            : #define DCHECK(condition) CHECK(condition)
<span class="lineNum">     971 </span>            : #define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)
<span class="lineNum">     972 </span>            : #define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)
<span class="lineNum">     973 </span>            : #define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)
<span class="lineNum">     974 </span>            : #define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)
<span class="lineNum">     975 </span>            : #define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)
<span class="lineNum">     976 </span>            : #define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)
<span class="lineNum">     977 </span>            : #define DCHECK_NOTNULL(val) CHECK_NOTNULL(val)
<span class="lineNum">     978 </span>            : #define DCHECK_STREQ(str1, str2) CHECK_STREQ(str1, str2)
<span class="lineNum">     979 </span>            : #define DCHECK_STRCASEEQ(str1, str2) CHECK_STRCASEEQ(str1, str2)
<span class="lineNum">     980 </span>            : #define DCHECK_STRNE(str1, str2) CHECK_STRNE(str1, str2)
<span class="lineNum">     981 </span>            : #define DCHECK_STRCASENE(str1, str2) CHECK_STRCASENE(str1, str2)
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            : #else  // NDEBUG
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : #define DLOG(severity) \
<span class="lineNum">     986 </span>            :   true ? (void) 0 : google::LogMessageVoidify() &amp; LOG(severity)
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            : #define DVLOG(verboselevel) \
<span class="lineNum">     989 </span>            :   (true || !VLOG_IS_ON(verboselevel)) ?\
<span class="lineNum">     990 </span>            :     (void) 0 : google::LogMessageVoidify() &amp; LOG(INFO)
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            : #define DLOG_IF(severity, condition) \
<span class="lineNum">     993 </span>            :   (true || !(condition)) ? (void) 0 : google::LogMessageVoidify() &amp; LOG(severity)
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : #define DLOG_EVERY_N(severity, n) \
<span class="lineNum">     996 </span>            :   true ? (void) 0 : google::LogMessageVoidify() &amp; LOG(severity)
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : #define DLOG_IF_EVERY_N(severity, condition, n) \
<span class="lineNum">     999 </span>            :   (true || !(condition))? (void) 0 : google::LogMessageVoidify() &amp; LOG(severity)
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            : #define DLOG_ASSERT(condition) \
<span class="lineNum">    1002 </span>            :   true ? (void) 0 : LOG_ASSERT(condition)
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            : // MSVC warning C4127: conditional expression is constant
<span class="lineNum">    1005 </span>            : #define DCHECK(condition) \
<span class="lineNum">    1006 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1007 </span>            :   while (false) \
<span class="lineNum">    1008 </span>            :     GLOG_MSVC_POP_WARNING() CHECK(condition)
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            : #define DCHECK_EQ(val1, val2) \
<span class="lineNum">    1011 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1012 </span>            :   while (false) \
<span class="lineNum">    1013 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_EQ(val1, val2)
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : #define DCHECK_NE(val1, val2) \
<span class="lineNum">    1016 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1017 </span>            :   while (false) \
<span class="lineNum">    1018 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_NE(val1, val2)
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            : #define DCHECK_LE(val1, val2) \
<span class="lineNum">    1021 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1022 </span>            :   while (false) \
<span class="lineNum">    1023 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_LE(val1, val2)
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            : #define DCHECK_LT(val1, val2) \
<span class="lineNum">    1026 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1027 </span>            :   while (false) \
<span class="lineNum">    1028 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_LT(val1, val2)
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : #define DCHECK_GE(val1, val2) \
<span class="lineNum">    1031 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1032 </span>            :   while (false) \
<span class="lineNum">    1033 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_GE(val1, val2)
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            : #define DCHECK_GT(val1, val2) \
<span class="lineNum">    1036 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1037 </span>            :   while (false) \
<span class="lineNum">    1038 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_GT(val1, val2)
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            : // You may see warnings in release mode if you don't use the return
<span class="lineNum">    1041 </span>            : // value of DCHECK_NOTNULL. Please just use DCHECK for such cases.
<span class="lineNum">    1042 </span>            : #define DCHECK_NOTNULL(val) (val)
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : #define DCHECK_STREQ(str1, str2) \
<span class="lineNum">    1045 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1046 </span>            :   while (false) \
<span class="lineNum">    1047 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_STREQ(str1, str2)
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            : #define DCHECK_STRCASEEQ(str1, str2) \
<span class="lineNum">    1050 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1051 </span>            :   while (false) \
<span class="lineNum">    1052 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_STRCASEEQ(str1, str2)
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            : #define DCHECK_STRNE(str1, str2) \
<span class="lineNum">    1055 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1056 </span>            :   while (false) \
<span class="lineNum">    1057 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_STRNE(str1, str2)
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            : #define DCHECK_STRCASENE(str1, str2) \
<span class="lineNum">    1060 </span>            :   GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
<span class="lineNum">    1061 </span>            :   while (false) \
<span class="lineNum">    1062 </span>            :     GLOG_MSVC_POP_WARNING() CHECK_STRCASENE(str1, str2)
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            : #endif  // NDEBUG
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            : // Log only in verbose mode.
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            : #define VLOG(verboselevel) LOG_IF(INFO, VLOG_IS_ON(verboselevel))
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            : #define VLOG_IF(verboselevel, condition) \
<span class="lineNum">    1071 </span>            :   LOG_IF(INFO, (condition) &amp;&amp; VLOG_IS_ON(verboselevel))
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            : #define VLOG_EVERY_N(verboselevel, n) \
<span class="lineNum">    1074 </span>            :   LOG_IF_EVERY_N(INFO, VLOG_IS_ON(verboselevel), n)
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : #define VLOG_IF_EVERY_N(verboselevel, condition, n) \
<span class="lineNum">    1077 </span>            :   LOG_IF_EVERY_N(INFO, (condition) &amp;&amp; VLOG_IS_ON(verboselevel), n)
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : namespace base_logging {
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            : // LogMessage::LogStream is a std::ostream backed by this streambuf.
<span class="lineNum">    1082 </span>            : // This class ignores overflow and leaves two bytes at the end of the
<span class="lineNum">    1083 </span>            : // buffer to allow for a '\n' and '\0'.
<span class="lineNum">    1084 </span>            : class GOOGLE_GLOG_DLL_DECL LogStreamBuf : public std::streambuf {
<span class="lineNum">    1085 </span>            :  public:
<span class="lineNum">    1086 </span>            :   // REQUIREMENTS: &quot;len&quot; must be &gt;= 2 to account for the '\n' and '\n'.
<span class="lineNum">    1087 </span>            :   LogStreamBuf(char *buf, int len) {
<span class="lineNum">    1088 </span>            :     setp(buf, buf + len - 2);
<span class="lineNum">    1089 </span>            :   }
<span class="lineNum">    1090 </span>            :   // This effectively ignores overflow.
<span class="lineNum">    1091 </span>            :   virtual int_type overflow(int_type ch) {
<span class="lineNum">    1092 </span>            :     return ch;
<span class="lineNum">    1093 </span>            :   }
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :   // Legacy public ostrstream method.
<span class="lineNum">    1096 </span>            :   size_t pcount() const { return pptr() - pbase(); }
<span class="lineNum">    1097 </span>            :   char* pbase() const { return std::streambuf::pbase(); }
<span class="lineNum">    1098 </span>            : };
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : }  // namespace base_logging
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            : //
<span class="lineNum">    1103 </span>            : // This class more or less represents a particular log message.  You
<span class="lineNum">    1104 </span>            : // create an instance of LogMessage and then stream stuff to it.
<span class="lineNum">    1105 </span>            : // When you finish streaming to it, ~LogMessage is called and the
<span class="lineNum">    1106 </span>            : // full message gets streamed to the appropriate destination.
<span class="lineNum">    1107 </span>            : //
<span class="lineNum">    1108 </span>            : // You shouldn't actually use LogMessage's constructor to log things,
<span class="lineNum">    1109 </span>            : // though.  You should use the LOG() macro (and variants thereof)
<span class="lineNum">    1110 </span>            : // above.
<span class="lineNum">    1111 </span>            : class GOOGLE_GLOG_DLL_DECL LogMessage {
<span class="lineNum">    1112 </span>            : public:
<span class="lineNum">    1113 </span>            :   enum {
<span class="lineNum">    1114 </span>            :     // Passing kNoLogPrefix for the line number disables the
<span class="lineNum">    1115 </span>            :     // log-message prefix. Useful for using the LogMessage
<span class="lineNum">    1116 </span>            :     // infrastructure as a printing utility. See also the --log_prefix
<span class="lineNum">    1117 </span>            :     // flag for controlling the log-message prefix on an
<span class="lineNum">    1118 </span>            :     // application-wide basis.
<span class="lineNum">    1119 </span>            :     kNoLogPrefix = -1
<span class="lineNum">    1120 </span>            :   };
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   // LogStream inherit from non-DLL-exported class (std::ostrstream)
<span class="lineNum">    1123 </span>            :   // and VC++ produces a warning for this situation.
<span class="lineNum">    1124 </span>            :   // However, MSDN says &quot;C4275 can be ignored in Microsoft Visual C++
<span class="lineNum">    1125 </span>            :   // 2005 if you are deriving from a type in the Standard C++ Library&quot;
<span class="lineNum">    1126 </span>            :   // http://msdn.microsoft.com/en-us/library/3tdb471s(VS.80).aspx
<span class="lineNum">    1127 </span>            :   // Let's just ignore the warning.
<span class="lineNum">    1128 </span>            : #ifdef _MSC_VER
<span class="lineNum">    1129 </span>            : # pragma warning(disable: 4275)
<span class="lineNum">    1130 </span>            : #endif
<span class="lineNum">    1131 </span>            :   class GOOGLE_GLOG_DLL_DECL LogStream : public std::ostream {
<span class="lineNum">    1132 </span>            : #ifdef _MSC_VER
<span class="lineNum">    1133 </span>            : # pragma warning(default: 4275)
<span class="lineNum">    1134 </span>            : #endif
<span class="lineNum">    1135 </span>            :   public:
<span class="lineNum">    1136 </span>            :     LogStream(char *buf, int len, int ctr)
<span class="lineNum">    1137 </span>            :         : std::ostream(NULL),
<span class="lineNum">    1138 </span>            :           streambuf_(buf, len),
<span class="lineNum">    1139 </span>            :           ctr_(ctr),
<span class="lineNum">    1140 </span>            :           self_(this) {
<span class="lineNum">    1141 </span>            :       rdbuf(&amp;streambuf_);
<span class="lineNum">    1142 </span>            :     }
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :     int ctr() const { return ctr_; }
<span class="lineNum">    1145 </span>            :     void set_ctr(int ctr) { ctr_ = ctr; }
<span class="lineNum">    1146 </span>            :     LogStream* self() const { return self_; }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span>            :     // Legacy std::streambuf methods.
<span class="lineNum">    1149 </span>            :     size_t pcount() const { return streambuf_.pcount(); }
<span class="lineNum">    1150 </span>            :     char* pbase() const { return streambuf_.pbase(); }
<span class="lineNum">    1151 </span>            :     char* str() const { return pbase(); }
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :   private:
<span class="lineNum">    1154 </span>            :     base_logging::LogStreamBuf streambuf_;
<span class="lineNum">    1155 </span>            :     int ctr_;  // Counter hack (for the LOG_EVERY_X() macro)
<span class="lineNum">    1156 </span>            :     LogStream *self_;  // Consistency check hack
<span class="lineNum">    1157 </span>            :   };
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            : public:
<span class="lineNum">    1160 </span>            :   // icc 8 requires this typedef to avoid an internal compiler error.
<span class="lineNum">    1161 </span>            :   typedef void (LogMessage::*SendMethod)();
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :   LogMessage(const char* file, int line, LogSeverity severity, int ctr,
<span class="lineNum">    1164 </span>            :              SendMethod send_method);
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            :   // Two special constructors that generate reduced amounts of code at
<span class="lineNum">    1167 </span>            :   // LOG call sites for common cases.
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            :   // Used for LOG(INFO): Implied are:
<span class="lineNum">    1170 </span>            :   // severity = INFO, ctr = 0, send_method = &amp;LogMessage::SendToLog.
<span class="lineNum">    1171 </span>            :   //
<span class="lineNum">    1172 </span>            :   // Using this constructor instead of the more complex constructor above
<span class="lineNum">    1173 </span>            :   // saves 19 bytes per call site.
<span class="lineNum">    1174 </span>            :   LogMessage(const char* file, int line);
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            :   // Used for LOG(severity) where severity != INFO.  Implied
<span class="lineNum">    1177 </span>            :   // are: ctr = 0, send_method = &amp;LogMessage::SendToLog
<span class="lineNum">    1178 </span>            :   //
<span class="lineNum">    1179 </span>            :   // Using this constructor instead of the more complex constructor above
<span class="lineNum">    1180 </span>            :   // saves 17 bytes per call site.
<span class="lineNum">    1181 </span>            :   LogMessage(const char* file, int line, LogSeverity severity);
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :   // Constructor to log this message to a specified sink (if not NULL).
<span class="lineNum">    1184 </span>            :   // Implied are: ctr = 0, send_method = &amp;LogMessage::SendToSinkAndLog if
<span class="lineNum">    1185 </span>            :   // also_send_to_log is true, send_method = &amp;LogMessage::SendToSink otherwise.
<span class="lineNum">    1186 </span>            :   LogMessage(const char* file, int line, LogSeverity severity, LogSink* sink,
<span class="lineNum">    1187 </span>            :              bool also_send_to_log);
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :   // Constructor where we also give a vector&lt;string&gt; pointer
<span class="lineNum">    1190 </span>            :   // for storing the messages (if the pointer is not NULL).
<span class="lineNum">    1191 </span>            :   // Implied are: ctr = 0, send_method = &amp;LogMessage::SaveOrSendToLog.
<span class="lineNum">    1192 </span>            :   LogMessage(const char* file, int line, LogSeverity severity,
<span class="lineNum">    1193 </span>            :              std::vector&lt;std::string&gt;* outvec);
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            :   // Constructor where we also give a string pointer for storing the
<span class="lineNum">    1196 </span>            :   // message (if the pointer is not NULL).  Implied are: ctr = 0,
<span class="lineNum">    1197 </span>            :   // send_method = &amp;LogMessage::WriteToStringAndLog.
<span class="lineNum">    1198 </span>            :   LogMessage(const char* file, int line, LogSeverity severity,
<span class="lineNum">    1199 </span>            :              std::string* message);
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span>            :   // A special constructor used for check failures
<span class="lineNum">    1202 </span>            :   LogMessage(const char* file, int line, const CheckOpString&amp; result);
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            :   ~LogMessage();
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :   // Flush a buffered message to the sink set in the constructor.  Always
<span class="lineNum">    1207 </span>            :   // called by the destructor, it may also be called from elsewhere if
<span class="lineNum">    1208 </span>            :   // needed.  Only the first call is actioned; any later ones are ignored.
<span class="lineNum">    1209 </span>            :   void Flush();
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :   // An arbitrary limit on the length of a single log message.  This
<span class="lineNum">    1212 </span>            :   // is so that streaming can be done more efficiently.
<span class="lineNum">    1213 </span>            :   static const size_t kMaxLogMessageLen;
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            :   // Theses should not be called directly outside of logging.*,
<span class="lineNum">    1216 </span>            :   // only passed as SendMethod arguments to other LogMessage methods:
<span class="lineNum">    1217 </span>            :   void SendToLog();  // Actually dispatch to the logs
<span class="lineNum">    1218 </span>            :   void SendToSyslogAndLog();  // Actually dispatch to syslog and the logs
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            :   // Call abort() or similar to perform LOG(FATAL) crash.
<span class="lineNum">    1221 </span>            :   static void Fail() __attribute__ ((noreturn));
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            :   std::ostream&amp; stream();
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            :   int preserved_errno() const;
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            :   // Must be called without the log_mutex held.  (L &lt; log_mutex)
<span class="lineNum">    1228 </span>            :   static int64 num_messages(int severity);
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span>            :   struct LogMessageData;
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            : private:
<span class="lineNum">    1233 </span>            :   // Fully internal SendMethod cases:
<span class="lineNum">    1234 </span>            :   void SendToSinkAndLog();  // Send to sink if provided and dispatch to the logs
<span class="lineNum">    1235 </span>            :   void SendToSink();  // Send to sink if provided, do nothing otherwise.
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            :   // Write to string if provided and dispatch to the logs.
<span class="lineNum">    1238 </span>            :   void WriteToStringAndLog();
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            :   void SaveOrSendToLog();  // Save to stringvec if provided, else to logs
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            :   void Init(const char* file, int line, LogSeverity severity,
<span class="lineNum">    1243 </span>            :             void (LogMessage::*send_method)());
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :   // Used to fill in crash information during LOG(FATAL) failures.
<span class="lineNum">    1246 </span>            :   void RecordCrashReason(glog_internal_namespace_::CrashReason* reason);
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            :   // Counts of messages sent at each priority:
<span class="lineNum">    1249 </span>            :   static int64 num_messages_[NUM_SEVERITIES];  // under log_mutex
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            :   // We keep the data in a separate struct so that each instance of
<span class="lineNum">    1252 </span>            :   // LogMessage uses less stack space.
<span class="lineNum">    1253 </span>            :   LogMessageData* allocated_;
<span class="lineNum">    1254 </span>            :   LogMessageData* data_;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :   friend class LogDestination;
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span>            :   LogMessage(const LogMessage&amp;);
<span class="lineNum">    1259 </span>            :   void operator=(const LogMessage&amp;);
<span class="lineNum">    1260 </span>            : };
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            : // This class happens to be thread-hostile because all instances share
<span class="lineNum">    1263 </span>            : // a single data buffer, but since it can only be created just before
<span class="lineNum">    1264 </span>            : // the process dies, we don't worry so much.
<span class="lineNum">    1265 </span>            : class GOOGLE_GLOG_DLL_DECL LogMessageFatal : public LogMessage {
<span class="lineNum">    1266 </span>            :  public:
<span class="lineNum">    1267 </span>            :   LogMessageFatal(const char* file, int line);
<span class="lineNum">    1268 </span>            :   LogMessageFatal(const char* file, int line, const CheckOpString&amp; result);
<span class="lineNum">    1269 </span>            :   ~LogMessageFatal() __attribute__ ((noreturn));
<span class="lineNum">    1270 </span>            : };
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : // A non-macro interface to the log facility; (useful
<span class="lineNum">    1273 </span>            : // when the logging level is not a compile-time constant).
<span class="lineNum">    1274 </span>            : inline void LogAtLevel(int const severity, std::string const &amp;msg) {
<span class="lineNum">    1275 </span>            :   LogMessage(__FILE__, __LINE__, severity).stream() &lt;&lt; msg;
<span class="lineNum">    1276 </span>            : }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : // A macro alternative of LogAtLevel. New code may want to use this
<span class="lineNum">    1279 </span>            : // version since there are two advantages: 1. this version outputs the
<span class="lineNum">    1280 </span>            : // file name and the line number where this macro is put like other
<span class="lineNum">    1281 </span>            : // LOG macros, 2. this macro can be used as C++ stream.
<span class="lineNum">    1282 </span>            : #define LOG_AT_LEVEL(severity) google::LogMessage(__FILE__, __LINE__, severity).stream()
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            : // A small helper for CHECK_NOTNULL().
<span class="lineNum">    1285 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1286 </span>            : T* CheckNotNull(const char *file, int line, const char *names, T* t) {
<span class="lineNum">    1287 </span>            :   if (t == NULL) {
<span class="lineNum">    1288 </span>            :     LogMessageFatal(file, line, new std::string(names));
<span class="lineNum">    1289 </span>            :   }
<span class="lineNum">    1290 </span>            :   return t;
<span class="lineNum">    1291 </span>            : }
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            : // Allow folks to put a counter in the LOG_EVERY_X()'ed messages. This
<span class="lineNum">    1294 </span>            : // only works if ostream is a LogStream. If the ostream is not a
<span class="lineNum">    1295 </span>            : // LogStream you'll get an assert saying as much at runtime.
<span class="lineNum">    1296 </span>            : GOOGLE_GLOG_DLL_DECL std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os,
<span class="lineNum">    1297 </span>            :                                               const PRIVATE_Counter&amp;);
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            : // Derived class for PLOG*() above.
<span class="lineNum">    1301 </span>            : class GOOGLE_GLOG_DLL_DECL ErrnoLogMessage : public LogMessage {
<span class="lineNum">    1302 </span>            :  public:
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span>            :   ErrnoLogMessage(const char* file, int line, LogSeverity severity, int ctr,
<span class="lineNum">    1305 </span>            :                   void (LogMessage::*send_method)());
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            :   // Postpends &quot;: strerror(errno) [errno]&quot;.
<span class="lineNum">    1308 </span>            :   ~ErrnoLogMessage();
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :  private:
<span class="lineNum">    1311 </span>            :   ErrnoLogMessage(const ErrnoLogMessage&amp;);
<span class="lineNum">    1312 </span>            :   void operator=(const ErrnoLogMessage&amp;);
<span class="lineNum">    1313 </span>            : };
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            : // This class is used to explicitly ignore values in the conditional
<span class="lineNum">    1317 </span>            : // logging macros.  This avoids compiler warnings like &quot;value computed
<span class="lineNum">    1318 </span>            : // is not used&quot; and &quot;statement has no effect&quot;.
<span class="lineNum">    1319 </span>            : 
<a name="1320"><span class="lineNum">    1320 </span>            : class GOOGLE_GLOG_DLL_DECL LogMessageVoidify {</a>
<span class="lineNum">    1321 </span>            :  public:
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   LogMessageVoidify() { }</span>
<a name="1323"><span class="lineNum">    1323 </span>            :   // This has to be an operator with a precedence lower than &lt;&lt; but</a>
<span class="lineNum">    1324 </span>            :   // higher than ?:
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   void operator&amp;(std::ostream&amp;) { }</span>
<span class="lineNum">    1326 </span>            : };
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            : // Flushes all log files that contains messages that are at least of
<span class="lineNum">    1330 </span>            : // the specified severity level.  Thread-safe.
<span class="lineNum">    1331 </span>            : GOOGLE_GLOG_DLL_DECL void FlushLogFiles(LogSeverity min_severity);
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            : // Flushes all log files that contains messages that are at least of
<span class="lineNum">    1334 </span>            : // the specified severity level. Thread-hostile because it ignores
<span class="lineNum">    1335 </span>            : // locking -- used for catastrophic failures.
<span class="lineNum">    1336 </span>            : GOOGLE_GLOG_DLL_DECL void FlushLogFilesUnsafe(LogSeverity min_severity);
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            : //
<span class="lineNum">    1339 </span>            : // Set the destination to which a particular severity level of log
<span class="lineNum">    1340 </span>            : // messages is sent.  If base_filename is &quot;&quot;, it means &quot;don't log this
<span class="lineNum">    1341 </span>            : // severity&quot;.  Thread-safe.
<span class="lineNum">    1342 </span>            : //
<span class="lineNum">    1343 </span>            : GOOGLE_GLOG_DLL_DECL void SetLogDestination(LogSeverity severity,
<span class="lineNum">    1344 </span>            :                                             const char* base_filename);
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            : //
<span class="lineNum">    1347 </span>            : // Set the basename of the symlink to the latest log file at a given
<span class="lineNum">    1348 </span>            : // severity.  If symlink_basename is empty, do not make a symlink.  If
<span class="lineNum">    1349 </span>            : // you don't call this function, the symlink basename is the
<span class="lineNum">    1350 </span>            : // invocation name of the program.  Thread-safe.
<span class="lineNum">    1351 </span>            : //
<span class="lineNum">    1352 </span>            : GOOGLE_GLOG_DLL_DECL void SetLogSymlink(LogSeverity severity,
<span class="lineNum">    1353 </span>            :                                         const char* symlink_basename);
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            : //
<span class="lineNum">    1356 </span>            : // Used to send logs to some other kind of destination
<span class="lineNum">    1357 </span>            : // Users should subclass LogSink and override send to do whatever they want.
<span class="lineNum">    1358 </span>            : // Implementations must be thread-safe because a shared instance will
<span class="lineNum">    1359 </span>            : // be called from whichever thread ran the LOG(XXX) line.
<span class="lineNum">    1360 </span>            : class GOOGLE_GLOG_DLL_DECL LogSink {
<span class="lineNum">    1361 </span>            :  public:
<span class="lineNum">    1362 </span>            :   virtual ~LogSink();
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :   // Sink's logging logic (message_len is such as to exclude '\n' at the end).
<span class="lineNum">    1365 </span>            :   // This method can't use LOG() or CHECK() as logging system mutex(s) are held
<span class="lineNum">    1366 </span>            :   // during this call.
<span class="lineNum">    1367 </span>            :   virtual void send(LogSeverity severity, const char* full_filename,
<span class="lineNum">    1368 </span>            :                     const char* base_filename, int line,
<span class="lineNum">    1369 </span>            :                     const struct ::tm* tm_time,
<span class="lineNum">    1370 </span>            :                     const char* message, size_t message_len) = 0;
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span>            :   // Redefine this to implement waiting for
<span class="lineNum">    1373 </span>            :   // the sink's logging logic to complete.
<span class="lineNum">    1374 </span>            :   // It will be called after each send() returns,
<span class="lineNum">    1375 </span>            :   // but before that LogMessage exits or crashes.
<span class="lineNum">    1376 </span>            :   // By default this function does nothing.
<span class="lineNum">    1377 </span>            :   // Using this function one can implement complex logic for send()
<span class="lineNum">    1378 </span>            :   // that itself involves logging; and do all this w/o causing deadlocks and
<span class="lineNum">    1379 </span>            :   // inconsistent rearrangement of log messages.
<span class="lineNum">    1380 </span>            :   // E.g. if a LogSink has thread-specific actions, the send() method
<span class="lineNum">    1381 </span>            :   // can simply add the message to a queue and wake up another thread that
<span class="lineNum">    1382 </span>            :   // handles real logging while itself making some LOG() calls;
<span class="lineNum">    1383 </span>            :   // WaitTillSent() can be implemented to wait for that logic to complete.
<span class="lineNum">    1384 </span>            :   // See our unittest for an example.
<span class="lineNum">    1385 </span>            :   virtual void WaitTillSent();
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span>            :   // Returns the normal text output of the log message.
<span class="lineNum">    1388 </span>            :   // Can be useful to implement send().
<span class="lineNum">    1389 </span>            :   static std::string ToString(LogSeverity severity, const char* file, int line,
<span class="lineNum">    1390 </span>            :                               const struct ::tm* tm_time,
<span class="lineNum">    1391 </span>            :                               const char* message, size_t message_len);
<span class="lineNum">    1392 </span>            : };
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            : // Add or remove a LogSink as a consumer of logging data.  Thread-safe.
<span class="lineNum">    1395 </span>            : GOOGLE_GLOG_DLL_DECL void AddLogSink(LogSink *destination);
<span class="lineNum">    1396 </span>            : GOOGLE_GLOG_DLL_DECL void RemoveLogSink(LogSink *destination);
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            : //
<span class="lineNum">    1399 </span>            : // Specify an &quot;extension&quot; added to the filename specified via
<span class="lineNum">    1400 </span>            : // SetLogDestination.  This applies to all severity levels.  It's
<span class="lineNum">    1401 </span>            : // often used to append the port we're listening on to the logfile
<span class="lineNum">    1402 </span>            : // name.  Thread-safe.
<span class="lineNum">    1403 </span>            : //
<span class="lineNum">    1404 </span>            : GOOGLE_GLOG_DLL_DECL void SetLogFilenameExtension(
<span class="lineNum">    1405 </span>            :     const char* filename_extension);
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            : //
<span class="lineNum">    1408 </span>            : // Make it so that all log messages of at least a particular severity
<span class="lineNum">    1409 </span>            : // are logged to stderr (in addition to logging to the usual log
<span class="lineNum">    1410 </span>            : // file(s)).  Thread-safe.
<span class="lineNum">    1411 </span>            : //
<span class="lineNum">    1412 </span>            : GOOGLE_GLOG_DLL_DECL void SetStderrLogging(LogSeverity min_severity);
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            : //
<span class="lineNum">    1415 </span>            : // Make it so that all log messages go only to stderr.  Thread-safe.
<span class="lineNum">    1416 </span>            : //
<span class="lineNum">    1417 </span>            : GOOGLE_GLOG_DLL_DECL void LogToStderr();
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            : //
<span class="lineNum">    1420 </span>            : // Make it so that all log messages of at least a particular severity are
<span class="lineNum">    1421 </span>            : // logged via email to a list of addresses (in addition to logging to the
<span class="lineNum">    1422 </span>            : // usual log file(s)).  The list of addresses is just a string containing
<span class="lineNum">    1423 </span>            : // the email addresses to send to (separated by spaces, say).  Thread-safe.
<span class="lineNum">    1424 </span>            : //
<span class="lineNum">    1425 </span>            : GOOGLE_GLOG_DLL_DECL void SetEmailLogging(LogSeverity min_severity,
<span class="lineNum">    1426 </span>            :                                           const char* addresses);
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            : // A simple function that sends email. dest is a commma-separated
<span class="lineNum">    1429 </span>            : // list of addressess.  Thread-safe.
<span class="lineNum">    1430 </span>            : GOOGLE_GLOG_DLL_DECL bool SendEmail(const char *dest,
<span class="lineNum">    1431 </span>            :                                     const char *subject, const char *body);
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            : GOOGLE_GLOG_DLL_DECL const std::vector&lt;std::string&gt;&amp; GetLoggingDirectories();
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            : // For tests only:  Clear the internal [cached] list of logging directories to
<span class="lineNum">    1436 </span>            : // force a refresh the next time GetLoggingDirectories is called.
<span class="lineNum">    1437 </span>            : // Thread-hostile.
<span class="lineNum">    1438 </span>            : void TestOnly_ClearLoggingDirectoriesList();
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            : // Returns a set of existing temporary directories, which will be a
<span class="lineNum">    1441 </span>            : // subset of the directories returned by GetLogginDirectories().
<span class="lineNum">    1442 </span>            : // Thread-safe.
<span class="lineNum">    1443 </span>            : GOOGLE_GLOG_DLL_DECL void GetExistingTempDirectories(
<span class="lineNum">    1444 </span>            :     std::vector&lt;std::string&gt;* list);
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            : // Print any fatal message again -- useful to call from signal handler
<span class="lineNum">    1447 </span>            : // so that the last thing in the output is the fatal message.
<span class="lineNum">    1448 </span>            : // Thread-hostile, but a race is unlikely.
<span class="lineNum">    1449 </span>            : GOOGLE_GLOG_DLL_DECL void ReprintFatalMessage();
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            : // Truncate a log file that may be the append-only output of multiple
<span class="lineNum">    1452 </span>            : // processes and hence can't simply be renamed/reopened (typically a
<span class="lineNum">    1453 </span>            : // stdout/stderr).  If the file &quot;path&quot; is &gt; &quot;limit&quot; bytes, copy the
<span class="lineNum">    1454 </span>            : // last &quot;keep&quot; bytes to offset 0 and truncate the rest. Since we could
<span class="lineNum">    1455 </span>            : // be racing with other writers, this approach has the potential to
<span class="lineNum">    1456 </span>            : // lose very small amounts of data. For security, only follow symlinks
<span class="lineNum">    1457 </span>            : // if the path is /proc/self/fd/*
<span class="lineNum">    1458 </span>            : GOOGLE_GLOG_DLL_DECL void TruncateLogFile(const char *path,
<span class="lineNum">    1459 </span>            :                                           int64 limit, int64 keep);
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span>            : // Truncate stdout and stderr if they are over the value specified by
<span class="lineNum">    1462 </span>            : // --max_log_size; keep the final 1MB.  This function has the same
<span class="lineNum">    1463 </span>            : // race condition as TruncateLogFile.
<span class="lineNum">    1464 </span>            : GOOGLE_GLOG_DLL_DECL void TruncateStdoutStderr();
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span>            : // Return the string representation of the provided LogSeverity level.
<span class="lineNum">    1467 </span>            : // Thread-safe.
<span class="lineNum">    1468 </span>            : GOOGLE_GLOG_DLL_DECL const char* GetLogSeverityName(LogSeverity severity);
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            : // ---------------------------------------------------------------------
<span class="lineNum">    1471 </span>            : // Implementation details that are not useful to most clients
<span class="lineNum">    1472 </span>            : // ---------------------------------------------------------------------
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            : // A Logger is the interface used by logging modules to emit entries
<span class="lineNum">    1475 </span>            : // to a log.  A typical implementation will dump formatted data to a
<span class="lineNum">    1476 </span>            : // sequence of files.  We also provide interfaces that will forward
<span class="lineNum">    1477 </span>            : // the data to another thread so that the invoker never blocks.
<span class="lineNum">    1478 </span>            : // Implementations should be thread-safe since the logging system
<span class="lineNum">    1479 </span>            : // will write to them from multiple threads.
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : namespace base {
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            : class GOOGLE_GLOG_DLL_DECL Logger {
<span class="lineNum">    1484 </span>            :  public:
<span class="lineNum">    1485 </span>            :   virtual ~Logger();
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            :   // Writes &quot;message[0,message_len-1]&quot; corresponding to an event that
<span class="lineNum">    1488 </span>            :   // occurred at &quot;timestamp&quot;.  If &quot;force_flush&quot; is true, the log file
<span class="lineNum">    1489 </span>            :   // is flushed immediately.
<span class="lineNum">    1490 </span>            :   //
<span class="lineNum">    1491 </span>            :   // The input message has already been formatted as deemed
<span class="lineNum">    1492 </span>            :   // appropriate by the higher level logging facility.  For example,
<span class="lineNum">    1493 </span>            :   // textual log messages already contain timestamps, and the
<span class="lineNum">    1494 </span>            :   // file:linenumber header.
<span class="lineNum">    1495 </span>            :   virtual void Write(bool force_flush,
<span class="lineNum">    1496 </span>            :                      time_t timestamp,
<span class="lineNum">    1497 </span>            :                      const char* message,
<span class="lineNum">    1498 </span>            :                      int message_len) = 0;
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :   // Flush any buffered messages
<span class="lineNum">    1501 </span>            :   virtual void Flush() = 0;
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            :   // Get the current LOG file size.
<span class="lineNum">    1504 </span>            :   // The returned value is approximate since some
<span class="lineNum">    1505 </span>            :   // logged data may not have been flushed to disk yet.
<span class="lineNum">    1506 </span>            :   virtual uint32 LogSize() = 0;
<span class="lineNum">    1507 </span>            : };
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span>            : // Get the logger for the specified severity level.  The logger
<span class="lineNum">    1510 </span>            : // remains the property of the logging module and should not be
<span class="lineNum">    1511 </span>            : // deleted by the caller.  Thread-safe.
<span class="lineNum">    1512 </span>            : extern GOOGLE_GLOG_DLL_DECL Logger* GetLogger(LogSeverity level);
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span>            : // Set the logger for the specified severity level.  The logger
<span class="lineNum">    1515 </span>            : // becomes the property of the logging module and should not
<span class="lineNum">    1516 </span>            : // be deleted by the caller.  Thread-safe.
<span class="lineNum">    1517 </span>            : extern GOOGLE_GLOG_DLL_DECL void SetLogger(LogSeverity level, Logger* logger);
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            : }
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            : // glibc has traditionally implemented two incompatible versions of
<span class="lineNum">    1522 </span>            : // strerror_r(). There is a poorly defined convention for picking the
<span class="lineNum">    1523 </span>            : // version that we want, but it is not clear whether it even works with
<span class="lineNum">    1524 </span>            : // all versions of glibc.
<span class="lineNum">    1525 </span>            : // So, instead, we provide this wrapper that automatically detects the
<span class="lineNum">    1526 </span>            : // version that is in use, and then implements POSIX semantics.
<span class="lineNum">    1527 </span>            : // N.B. In addition to what POSIX says, we also guarantee that &quot;buf&quot; will
<span class="lineNum">    1528 </span>            : // be set to an empty string, if this function failed. This means, in most
<span class="lineNum">    1529 </span>            : // cases, you do not need to check the error code and you can directly
<span class="lineNum">    1530 </span>            : // use the value of &quot;buf&quot;. It will never have an undefined value.
<span class="lineNum">    1531 </span>            : // DEPRECATED: Use StrError(int) instead.
<span class="lineNum">    1532 </span>            : GOOGLE_GLOG_DLL_DECL int posix_strerror_r(int err, char *buf, size_t len);
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            : // A thread-safe replacement for strerror(). Returns a string describing the
<span class="lineNum">    1535 </span>            : // given POSIX error code.
<span class="lineNum">    1536 </span>            : GOOGLE_GLOG_DLL_DECL std::string StrError(int err);
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            : // A class for which we define operator&lt;&lt;, which does nothing.
<span class="lineNum">    1539 </span>            : class GOOGLE_GLOG_DLL_DECL NullStream : public LogMessage::LogStream {
<span class="lineNum">    1540 </span>            :  public:
<span class="lineNum">    1541 </span>            :   // Initialize the LogStream so the messages can be written somewhere
<span class="lineNum">    1542 </span>            :   // (they'll never be actually displayed). This will be needed if a
<span class="lineNum">    1543 </span>            :   // NullStream&amp; is implicitly converted to LogStream&amp;, in which case
<span class="lineNum">    1544 </span>            :   // the overloaded NullStream::operator&lt;&lt; will not be invoked.
<span class="lineNum">    1545 </span>            :   NullStream() : LogMessage::LogStream(message_buffer_, 1, 0) { }
<span class="lineNum">    1546 </span>            :   NullStream(const char* /*file*/, int /*line*/,
<span class="lineNum">    1547 </span>            :              const CheckOpString&amp; /*result*/) :
<span class="lineNum">    1548 </span>            :       LogMessage::LogStream(message_buffer_, 1, 0) { }
<span class="lineNum">    1549 </span>            :   NullStream &amp;stream() { return *this; }
<span class="lineNum">    1550 </span>            :  private:
<span class="lineNum">    1551 </span>            :   // A very short buffer for messages (which we discard anyway). This
<span class="lineNum">    1552 </span>            :   // will be needed if NullStream&amp; converted to LogStream&amp; (e.g. as a
<span class="lineNum">    1553 </span>            :   // result of a conditional expression).
<span class="lineNum">    1554 </span>            :   char message_buffer_[2];
<span class="lineNum">    1555 </span>            : };
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            : // Do nothing. This operator is inline, allowing the message to be
<span class="lineNum">    1558 </span>            : // compiled away. The message will not be compiled away if we do
<span class="lineNum">    1559 </span>            : // something like (flag ? LOG(INFO) : LOG(ERROR)) &lt;&lt; message; when
<span class="lineNum">    1560 </span>            : // SKIP_LOG=WARNING. In those cases, NullStream will be implicitly
<span class="lineNum">    1561 </span>            : // converted to LogStream and the message will be computed and then
<span class="lineNum">    1562 </span>            : // quietly discarded.
<span class="lineNum">    1563 </span>            : template&lt;class T&gt;
<span class="lineNum">    1564 </span>            : inline NullStream&amp; operator&lt;&lt;(NullStream &amp;str, const T &amp;) { return str; }
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            : // Similar to NullStream, but aborts the program (without stack
<span class="lineNum">    1567 </span>            : // trace), like LogMessageFatal.
<span class="lineNum">    1568 </span>            : class GOOGLE_GLOG_DLL_DECL NullStreamFatal : public NullStream {
<span class="lineNum">    1569 </span>            :  public:
<span class="lineNum">    1570 </span>            :   NullStreamFatal() { }
<span class="lineNum">    1571 </span>            :   NullStreamFatal(const char* file, int line, const CheckOpString&amp; result) :
<span class="lineNum">    1572 </span>            :       NullStream(file, line, result) { }
<span class="lineNum">    1573 </span>            :   __attribute__ ((noreturn)) ~NullStreamFatal() { _exit(1); }
<span class="lineNum">    1574 </span>            : };
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span>            : // Install a signal handler that will dump signal information and a stack
<span class="lineNum">    1577 </span>            : // trace when the program crashes on certain signals.  We'll install the
<span class="lineNum">    1578 </span>            : // signal handler for the following signals.
<span class="lineNum">    1579 </span>            : //
<span class="lineNum">    1580 </span>            : // SIGSEGV, SIGILL, SIGFPE, SIGABRT, SIGBUS, and SIGTERM.
<span class="lineNum">    1581 </span>            : //
<span class="lineNum">    1582 </span>            : // By default, the signal handler will write the failure dump to the
<span class="lineNum">    1583 </span>            : // standard error.  You can customize the destination by installing your
<span class="lineNum">    1584 </span>            : // own writer function by InstallFailureWriter() below.
<span class="lineNum">    1585 </span>            : //
<span class="lineNum">    1586 </span>            : // Note on threading:
<span class="lineNum">    1587 </span>            : //
<span class="lineNum">    1588 </span>            : // The function should be called before threads are created, if you want
<span class="lineNum">    1589 </span>            : // to use the failure signal handler for all threads.  The stack trace
<span class="lineNum">    1590 </span>            : // will be shown only for the thread that receives the signal.  In other
<span class="lineNum">    1591 </span>            : // words, stack traces of other threads won't be shown.
<span class="lineNum">    1592 </span>            : GOOGLE_GLOG_DLL_DECL void InstallFailureSignalHandler();
<span class="lineNum">    1593 </span>            : 
<span class="lineNum">    1594 </span>            : // Installs a function that is used for writing the failure dump.  &quot;data&quot;
<span class="lineNum">    1595 </span>            : // is the pointer to the beginning of a message to be written, and &quot;size&quot;
<span class="lineNum">    1596 </span>            : // is the size of the message.  You should not expect the data is
<span class="lineNum">    1597 </span>            : // terminated with '\0'.
<span class="lineNum">    1598 </span>            : GOOGLE_GLOG_DLL_DECL void InstallFailureWriter(
<span class="lineNum">    1599 </span>            :     void (*writer)(const char* data, int size));
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            : }
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            : #endif // _LOGGING_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
